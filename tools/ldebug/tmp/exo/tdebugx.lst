     1                                  
     2                                  %if 0
     3                                  
     4                                  lDOS iniload packed payload
     5                                   by C. Masloch, 2018-2020
     6                                  
     7                                  Usage of the works is permitted provided that this
     8                                  instrument is retained with the works, so that any entity
     9                                  that uses the works is notified of this instrument.
    10                                  
    11                                  DISCLAIMER: THE WORKS ARE WITHOUT WARRANTY.
    12                                  
    13                                  
    14                                  Includes one of several depackers, some of which are under
    15                                  separate usage conditions. Refer to the individual depacker
    16                                  source files for the applicable usage conditions.
    17                                  
    18                                  %endif
    19                                  
    20                                  %include "lmacros3.mac"
     1                              <1> [list -]
    14                              <2> [list -]
    14                              <1> [list -]
    21                                  
    22                                  	struc LOADSTACKVARS, -10h
    23 FFFFFFF0 ????????                lsvFirstCluster:	resd 1
    24 FFFFFFF4 ????????                lsvFATSector:		resd 1
    25 FFFFFFF8 ????                    lsvFATSeg:		resw 1
    26 FFFFFFFA ????                    lsvLoadSeg:		resw 1
    27 FFFFFFFC ????????                lsvDataStart:		resd 1
    28                                  	endstruc
    29                                  
    30                                  	struc LOADDATA, LOADSTACKVARS - 10h
    31 FFFFFFE0 ????                    ldMemoryTop:	resw 1
    32 FFFFFFE2 ????                    ldLoadTop:	resw 1
    33 FFFFFFE4 ????                    ldSectorSeg:	resw 1
    34 FFFFFFE6 ??                      ldFATType:	resb 1
    35 FFFFFFE7 ??                      ldHasLBA:	resb 1
    36 FFFFFFE8 ????                    ldClusterSize:	resw 1
    37 FFFFFFEA ????                    ldParaPerSector:resw 1
    38 FFFFFFEC ????                    ldLoadingSeg:	resw 1
    39 FFFFFFEE ????                    ldLoadUntilSeg:	resw 1
    40                                  	endstruc
    41                                  
    42                                  
    43                                  %ifndef _MAP
    44                                  %elifempty _MAP
    45                                  %else	; defined non-empty, str or non-str
    46                                  	[map all _MAP]
    47                                  %endif
    48                                  
    49                                  	defaulting
    50                                  
    51                                  	numdef DEBUG0		; use errordata to generate an error code
    52                                  	numdef DEBUG1		; dump_stack_frame after an error occurred
    53                                  	numdef DEBUG2		; dump_stack_frame before blz_depack_safe call
    54                                  	numdef DEBUG3		; dump_stack_frame at start of blz_depack_safe
    55                                  
    56                                  	numdef ALLOW_OVERLAPPING,	1	; allow overlapping src and dst
    57                                  	numdef TEST_PROGRAM,		0
    58                                  	numdef TEST_PROGRAM_DECOMPRESSED_SIZE,		0,0
    59                                  %if _TEST_PROGRAM && ! _TEST_PROGRAM_DECOMPRESSED_SIZE
    60                                   %error Test program has to learn of decompressed size.
    61                                  %endif
    62                                  	numdef TEST_PROGRESS,	0
    63                                  
    64                                  	numdef EXEC_OFFSET,	0
    65                                  	numdef EXEC_SEGMENT,	0
    66                                  	numdef IMAGE_EXE,	0
    67                                  %if ! _IMAGE_EXE && _TEST_PROGRAM
    68                                   %error Test program can only be used as EXE.
    69                                  %endif
    70                                  	numdef IMAGE_EXE_CS,	-16	; relative-segment for CS
    71                                  	numdef IMAGE_EXE_IP,	256 +64	; value for IP
    72                                  		; The next two are only used if _IMAGE_EXE_AUTO_STACK is 0.
    73                                  	numdef IMAGE_EXE_SS,	-16	; relative-segment for SS
    74                                  	numdef IMAGE_EXE_SP,	0FFFEh	; value for SP (0 underflows)
    75                                  	numdef IMAGE_EXE_AUTO_STACK,	0, 2048	; use stack behind image
    76                                  		; _IMAGE_EXE_AUTO_STACK here differs from iniload's def of
    77                                  		;  the same name. This one is only used as a flag; if non-zero,
    78                                  		;  keep the stack given to us by iniload; if zero, set up the
    79                                  		;  stack specified by _IMAGE_EXE_SS and _IMAGE_EXE_SP.
    80                                  	numdef DEVICE,			0
    81                                  	gendef DEVICE_NAME,		""
    82                                  	numdef DEVICE_ATTRIBUTE,	8000h
    83                                  	numdef DEVICE_ZERO_ENTRYPOINT,	0
    84                                  
    85                                  	numdef BRIEFLZ,		0
    86                                  	numdef LZ4,		0
    87                                  	numdef SNAPPY,		0
    88                                  	numdef EXODECR,		0
    89                                  	numdef X,		0
    90                                  	numdef HEATSHRINK,	0
    91                                  	numdef LZD,		0
    92                                  	numdef LZO,		0
    93                                  	numdef LZSA2,		0
    94                                  	numdef APL,		0
    95                                  	numdef BZP,		0
    96                                  %if (!!_BRIEFLZ + !!_LZ4 + !!_SNAPPY + !!_EXODECR + !!_X + !!_HEATSHRINK 	+ !!_LZD + !!_LZO + !!_LZSA2 + !!_APL + !!_BZP) != 1
    98                                   %fatal Exactly one compression method must be selected.
    99                                  %endif
   100                                  %assign ADDITIONAL_MEMORY 0
   101                                  %if _BRIEFLZ
   102                                  	strdef PAYLOAD_FILE,	"lDOSLOAD.BLZ"
   103                                  %elif _LZ4
   104                                  	strdef PAYLOAD_FILE,	"lDOSLOAD.LZ4"
   105                                  %elif _SNAPPY
   106                                  	strdef PAYLOAD_FILE,	"lDOSLOAD.SZ"
   107                                  %elif _EXODECR
   108                                  	strdef PAYLOAD_FILE,	"lDOSLOAD.EXO"
   109                                  %elif _X
   110                                  	strdef PAYLOAD_FILE,	"lDOSLOAD.X"
   111                                  %elif _HEATSHRINK
   112                                  	strdef PAYLOAD_FILE,	"lDOSLOAD.HS"
   113                                  %elif _LZD
   114                                  	strdef PAYLOAD_FILE,	"lDOSLOAD.LZ"
   115                                  %elif _LZO
   116                                  	strdef PAYLOAD_FILE,	"lDOSLOAD.LZO"
   117                                  %elif _LZSA2
   118                                  	strdef PAYLOAD_FILE,	"lDOSLOAD.SA2"
   119                                  %elif _APL
   120                                  	strdef PAYLOAD_FILE,	"lDOSLOAD.APL"
   121                                  %elif _BZP
   122                                  	strdef PAYLOAD_FILE,	"lDOSLOAD.BZP"
   123                                  %endif
   124                                  	numdef PAYLOAD_KERNEL_MAX_PARAS,	0, 0
   125                                  %if _PAYLOAD_KERNEL_MAX_PARAS && ! _IMAGE_EXE
   126                                   %error Kernel mode max paras requires building dual-mode executable
   127                                  %endif
   128                                  	numdef COUNTER,		0, 32
   129                                  %if (_COUNTER - 1) & _COUNTER
   130                                   %error COUNTER must be a power of two
   131                                  %endif
   132                                  
   133                                  	strdef INILOAD_CFG, ""
   134                                  %ifnidn _INILOAD_CFG, ""
   135                                   %include _INILOAD_CFG
     1                              <1> ; File auto-generated, do not edit.
     2                              <1> strdef INILOAD_SIGNATURE, "eb"
     3                              <1> %assign _DEVICE 1
     4                              <1> %assign _DEVICE_ZERO_ENTRYPOINT 1
     5                              <1> %assign _DEVICE_ATTRIBUTE 8000h
     6                              <1> %define _DEVICE_NAME "LDEBUG$$"
   136                                  %endif
   137                                  
   138                                  %if _DEVICE
   139                                   %ifidn _DEVICE_NAME, ""
   140                                    %error Device name must be set
   141                                   %endif
   142                                  %endif
   143                                  
   144                                  
   145                                  	cpu 8086
   146                                  	section INIT0 start=0 vstart=0
   147                                  init0_start:
   148                                  %if _DEVICE
   149                                  		; The device header is of a fixed format.
   150                                  		;  For our purposes, the 4-byte code for
   151                                  		;  each the strategy entry and the
   152                                  		;  interrupt entry is part of this format.
   153                                  		; (DOS may read the attributes or entrypoint
   154                                  		;  offsets before calling either, so in the inicomp
   155                                  		;  stage we need to recreate in the entrypoints part
   156                                  		;  exactly what the application has here.)
   157                                  device_header:
   158                                  .next:
   159                                   %if _DEVICE_ZERO_ENTRYPOINT
   160 00000000 EB3E                    	fill 2, -1, jmp strict short j_zero_entrypoint
   161 00000002 FFFF                    	dw -1
   162                                   %else
   163                                  	dd -1				; link to next device
   164                                   %endif
   165                                  .attributes:
   166 00000004 0080                    	dw _DEVICE_ATTRIBUTE		; attributes
   167                                  .strategy:
   168 00000006 [1200]                  	dw .strategy_entry		; -> strategy entry
   169                                  .interrupt:
   170 00000008 [1600]                  	dw .interrupt_entry		; -> interrupt entry
   171                                  .name:
   172 0000000A 4C44454255472424        	fill 8, 32, db _DEVICE_NAME	; character device name,
   173                                  					;  or block device number of units
   174                                  					;  + optional name
   175                                  .strategy_entry:
   176 00000012 E9DB0090                	fill 4, 90h, jmp device_entrypoint
   177                                  .interrupt_entry:
   178 00000016 CB90<rep 3h>            	fill 4, 90h, retf
   179                                  %endif
   180                                  
   181                                  
   182                                  %if _IMAGE_EXE || _DEVICE
   183 0000001A 90                      	nop
   184 0000001B 90<rep 5h>              	align 32, nop
   185                                  init0_kernel_entry:
   186                                  		; cs:ip = load seg : 32 here
   187                                  %if ($ - $$) != 32
   188                                   %error Wrong kernel mode entrypoint
   189                                  %endif
   190                                  %if _TEST_PROGRAM
   191                                  @@:
   192 00000020 CC                      	int3
   193 00000021 FB                      	sti
   194 00000022 F4                      	hlt
   195 00000023 EBFB                    	jmp @B
   196                                  %endif
   197                                  %if ! _IMAGE_EXE
   198                                  j_zero_entrypoint:
   199                                  %endif
   200 00000025 31DB                    	xor bx, bx		; 0 = kernel mode
   201 00000027 50                      	push ax
   202 00000028 8CC8                    	mov ax, cs
   203 0000002A 83C040                  	add ax, (init0_end - init0_start) >> 4
   204 0000002D 8B56E2                  	mov dx, word [ bp + ldLoadTop ]	; => after end of available space
   205 00000030 BE6000                  	mov si, 60h		; => destination
   206 00000033 EB71                    	jmp init0_common
   207                                  
   208                                   %if _IMAGE_EXE
   209 00000035 90<rep Bh>              	align 64, nop
   210                                  j_zero_entrypoint:
   211                                  init0_exe_entry:
   212                                  		; NOTE:	This part is called with ip = 256 + 64, cs = PSP.
   213                                  %if ($ - $$) != 64
   214                                   %error Wrong EXE mode entrypoint
   215                                  %endif
   216 00000040 BB0100                  	mov bx, 1		; EXE mode
   217 00000043 50                      	push ax
   218                                    %if _TEST_PROGRAM
   219 00000044 BE8100                  	mov si, 81h
   220 00000047 31D2                    	xor dx, dx
   221 00000049 31C0                    	xor ax, ax
   222                                  cmdline:
   223                                  .:
   224 0000004B AC                      	lodsb
   225 0000004C 3C09                    	cmp al, 9
   226 0000004E 74FB                    	je .
   227 00000050 3C20                    	cmp al, 32
   228 00000052 74F7                    	je .
   229 00000054 3C0D                    	cmp al, 13
   230 00000056 7441                    	je .end
   231 00000058 3C30                    	cmp al, '0'
   232 0000005A 721E                    	jb .notdigit
   233 0000005C 3C39                    	cmp al, '9'
   234 0000005E 771A                    	ja .notdigit
   235                                  .digit:
   236 00000060 2C30                    	sub al, '0'
   237 00000062 89D1                    	mov cx, dx		; times 1
   238 00000064 01D2                    	add dx, dx
   239 00000066 7222                    	jc .invalid
   240 00000068 01D2                    	add dx, dx		; times 4
   241 0000006A 721E                    	jc .invalid
   242 0000006C 01CA                    	add dx, cx		; times 5
   243 0000006E 721A                    	jc .invalid
   244 00000070 01D2                    	add dx, dx		; times 10
   245 00000072 7216                    	jc .invalid
   246 00000074 01C2                    	add dx, ax		; add in low digit
   247 00000076 7212                    	jc .invalid
   248 00000078 EBD1                    	jmp .
   249                                  
   250                                  .notdigit:
   251 0000007A 3C41                    	cmp al, 'A'
   252 0000007C 7411                    	je .a
   253 0000007E 3C61                    	cmp al, 'a'
   254 00000080 740D                    	je .a
   255 00000082 3C42                    	cmp al, 'B'
   256 00000084 740E                    	je .b
   257 00000086 3C62                    	cmp al, 'b'
   258 00000088 740A                    	je .b
   259                                  .invalid:
   260 0000008A BAFFFF                  	mov dx, -1		; invalid
   261 0000008D EB0A                    	jmp .end
   262                                  
   263                                  .a:
   264 0000008F 80E77F                  	and bh, ~ 80h
   265 00000092 EBB7                    	jmp .
   266                                  
   267                                  .b:
   268 00000094 80CF80                  	or bh, 80h
   269 00000097 EBB2                    	jmp .
   270                                  
   271                                  .end:
   272 00000099 52                      	push dx
   273                                    %endif
   274 0000009A 8CD2                    	mov dx, ss		; => after end of available space
   275 0000009C 8CC8                    	mov ax, cs
   276 0000009E 83C050                  	add ax, (256 + (init0_end - init0_start)) >> 4	; => source
   277 000000A1 8CCE                    	mov si, cs
   278 000000A3 83C610                  	add si, 256 >> 4	; => destination
   279                                   %endif
   280                                  
   281                                  init0_common:
   282                                  		; REM:	This part must be position-independent, as it is
   283                                  		;	 called either with ip = init0_common (kernel mode
   284                                  		;	 or device mode)
   285                                  		;	 or ip = init0_common + 256 (application mode).
   286                                  		; INP:	si => depack destination
   287                                  		;	ax => source of payload + INIT1
   288                                  		;	dx => behind available memory
   289                                  		; OUT:	cs:ip -> init1_start:
   290                                  		;	ax => INIT1
   291                                  		;	dx => payload source
   292                                  		;	si => depack destination
   293                                  		;	bx = mode
   294 000000A6 FC                      	cld
   295                                  %if _TEST_PROGRAM
   296 000000A7 81EAAE12                	sub dx, ( (payload_end - payload) ) >> 4
   297 000000AB 721A                    	jc .error
   298 000000AD B9C030                  	mov cx, ( (payload_end - payload) 		+ (init1_end - init1_start) 		+ (init2_end - init2_start) 		) >> 4
   302 000000B0 29CA                    	sub dx, cx
   303 000000B2 7213                    	jc .error
   304 000000B4 39C2                    	cmp dx, ax
   305 000000B6 720F                    	jb .error
   306                                  %else
   307                                  	mov cx, ( (payload_end - payload) 		+ (init1_end - init1_start) 		) >> 4
   310                                  				; cx = amount paragraphs in payload + INIT1
   311                                  	sub dx, cx		; => destination for payload + INIT1
   312                                  				;  (highest possible spot in available memory)
   313                                  %endif
   314 000000B8 56                      	push si			; preserve destination
   315 000000B9 E82101                  	call init0_movp		; move up payload + INIT1
   316 000000BC 5E                      	pop si
   317                                  %else
   318                                  	cld
   319                                  	mov ax, cs
   320                                  	add ax, (init0_end - init0_start) >> 4
   321                                  	mov cx, ( (payload_end - payload) 		+ (init1_end - init1_start) 		) >> 4
   324                                  	mov dx, word [ bp + ldLoadTop ]
   325                                  	sub dx, cx
   326                                  	call init0_movp
   327                                  %endif
   328                                  
   329 000000BD 89D0                    	mov ax, dx		; => payload
   330                                  %if _TEST_PROGRAM
   331 000000BF 05ED12                  	add ax, ( 		+ (payload_end - payload) 		+ (init1_end - init1_start) 		) >> 4		; => INIT2
   335                                  %else
   336                                  	add ax, ( 		+ (payload_end - payload) 		) >> 4		; => INIT1
   339                                  %endif
   340 000000C2 31C9                    	xor cx, cx
   341 000000C4 50                      	push ax
   342 000000C5 51                      	push cx
   343 000000C6 CB                      	retf			; jump to relocated INIT1:init1_start
   344                                  				;  or INIT2:init2_start
   345                                  
   346                                  
   347                                  %if _TEST_PROGRAM
   348                                  .error:
   349 000000C7 89DF                    	mov di, bx
   350                                  
   351 000000C9 0E                      	push cs
   352 000000CA 1F                      	pop ds
   353 000000CB BA[5F03]                	mov dx, init0_msg.error_stderr + 256
   354 000000CE B92500                  	mov cx, init0_msg.error_stderr.length
   355 000000D1 BB0200                  	mov bx, 2
   356 000000D4 B440                    	mov ah, 40h
   357 000000D6 CD21                    	int 21h
   358                                  
   359 000000D8 F7C70080                	test di, 8000h
   360 000000DC 750D                    	jnz @F
   361 000000DE BA[8403]                	mov dx, init0_msg.error_stdout + 256
   362 000000E1 B90700                  	mov cx, init0_msg.error_stdout.length
   363 000000E4 BB0100                  	mov bx, 1
   364 000000E7 B440                    	mov ah, 40h
   365 000000E9 CD21                    	int 21h
   366                                  @@:
   367 000000EB B8FF4C                  	mov ax, 4CFFh
   368 000000EE CD21                    	int 21h
   369                                  %endif
   370                                  
   371                                  
   372                                  %if _DEVICE
   373                                  device_entrypoint:
   374                                  %if _TEST_PROGRAM
   375                                  @@:
   376 000000F0 CC                      	int3
   377 000000F1 FB                      	sti
   378 000000F2 F4                      	hlt
   379 000000F3 EBFB                    	jmp @B
   380                                  %endif
   381 000000F5 26807F0200              	cmp byte [es:bx + 2], 0		; command code 0 (init) ?
   382 000000FA 7407                    	je @F
   383                                  
   384 000000FC 26C747030381            	mov word [es:bx + 3], 8103h	; error, done, code: unknown command
   385 00000102 CB                      	retf
   386                                  
   387                                  @@:
   388 00000103 2E830E[0000]FF          	or word [cs:device_header.next], -1
   389 00000109 0E                      	push cs
   390 0000010A 2EFF36[0600]            	push word [cs:device_header.strategy]
   391                                  					; -> far return to payload's strategy
   392 0000010F 55                      	push bp
   393 00000110 1E                      	push ds
   394 00000111 56                      	push si
   395 00000112 57                      	push di
   396 00000113 52                      	push dx
   397 00000114 51                      	push cx
   398 00000115 50                      	push ax
   399 00000116 53                      	push bx
   400 00000117 06                      	push es
   401                                  
   402 00000118 268B4710                	mov ax, word [es:bx + 14 + 2]
   403 0000011C 31D2                    	xor dx, dx
   404 0000011E B90400                  	mov cx, 4
   405                                  @@:
   406 00000121 D1E0                    	shl ax, 1
   407 00000123 D1D2                    	rcl dx, 1
   408 00000125 E2FA                    	loop @B
   409 00000127 2603470E                	add ax, word [es:bx + 14]
   410 0000012B 83D200                  	adc dx, 0		; dx:ax = linear address behind end
   411                                  
   412 0000012E B104                    	mov cl, 4
   413                                  @@:
   414 00000130 D1EA                    	shr dx, 1
   415 00000132 D1D8                    	rcr ax, 1
   416 00000134 E2FA                    	loop @B			; ax => behind end
   417                                  
   418 00000136 8CCF                    	mov di, cs
   419                                  image_size: equ  ( (init0_end - init0_start) 		+ (payload_end - payload) 		+ (init1_end - init1_start) 		)
   423 00000138 81C72D13                	add di, image_size >> 4		; di => end of image
   424                                  
   425 0000013C 39F8                    	cmp ax, di			; enough memory to hold all of us ?
   426 0000013E 7203E98A00              	jae .have_some_memory		; yes -->
   427                                  
   428 00000143 0E                      	push cs
   429 00000144 1F                      	pop ds
   430 00000145 BA[8401]                	mov dx, .msg_no_memory
   431 00000148 B409                    	mov ah, 09h
   432 0000014A CD21                    	int 21h
   433                                  
   434 0000014C B80030                  	mov ax, 3000h
   435 0000014F CD21                    	int 21h
   436 00000151 3C05                    	cmp al, 5
   437 00000153 7307                    	jae @F
   438 00000155 BA[A301]                	mov dx, .msg_dos_below_5
   439 00000158 B409                    	mov ah, 09h
   440 0000015A CD21                    	int 21h
   441                                  @@:
   442                                  
   443 0000015C BA[CA01]                	mov dx, .msg_linebreak
   444 0000015F B409                    	mov ah, 09h
   445 00000161 CD21                    	int 21h
   446                                  
   447                                  		; tear down the stack frame and modify the request header
   448 00000163 07                      	pop es
   449 00000164 5B                      	pop bx
   450 00000165 26C747030381            	mov word [es:bx + 3], 8103h	; set error, done, invalid command
   451 0000016B 26C6470D00              	mov byte [es:bx + 13], 0	; set number of units = 0
   452 00000170 268C4F10                	mov word [es:bx + 14 + 2], cs
   453 00000174 2683670E00              	and word [es:bx + 14], 0	; -> after end of memory to allocate
   454 00000179 58                      	pop ax
   455 0000017A 59                      	pop cx
   456 0000017B 5A                      	pop dx
   457 0000017C 5F                      	pop di
   458 0000017D 5E                      	pop si
   459 0000017E 1F                      	pop ds
   460 0000017F 5D                      	pop bp
   461 00000180 83C404                  	add sp, 4		; discard far return to payload's strategy
   462 00000183 CB                      	retf			; return to DOS
   463                                  
   464 00000184 4C6F6164206572726F-     .msg_no_memory:		ascic "Load error: Not enough memory."
   464 0000018D 723A204E6F7420656E-
   464 00000196 6F756768206D656D6F-
   464 0000019F 72792E24           
   465 000001A3 204E6F74653A20444F-     .msg_dos_below_5:	ascic " Note: DOS must be at least version 5."
   465 000001AC 53206D757374206265-
   465 000001B5 206174206C65617374-
   465 000001BE 2076657273696F6E20-
   465 000001C7 352E24             
   466 000001CA 0D0A24                  .msg_linebreak:		ascic 13,10
   467                                  
   468                                  
   469                                  .have_some_memory:
   470 000001CD 89C2                    	mov dx, ax		; => after end of memory
   471 000001CF BB0200                  	mov bx, 2		; device mode
   472 000001D2 50                      	push ax
   473 000001D3 8CC8                    	mov ax, cs
   474 000001D5 83C040                  	add ax, (init0_end - init0_start) >> 4
   475 000001D8 8CCE                    	mov si, cs		; => destination
   476 000001DA E9C9FE                  	jmp init0_common
   477                                  %endif
   478                                  
   479                                  
   480                                  		; Move paragraphs
   481                                  		;
   482                                  		; INP:	ax => source
   483                                  		;	dx => destination
   484                                  		;	cx = number of paragraphs
   485                                  		; CHG:	cx, ds, si, es, di
   486                                  		; OUT:	ax and dx unchanged
   487                                  		; Note:	Doesn't work correctly on HMA; doesn't always wrap to LMA either.
   488                                  		;	Do not provide a wrapped/HMA source or destination!
   489                                  init0_movp:
   490 000001DD 39D0                    	cmp ax, dx		; source above destination ?
   491 000001DF 770A                    	ja .up			; yes, move up (forwards) -->
   492 000001E1 747B                    	je .return		; same, no need to move -->
   493 000001E3 50                      	push ax
   494 000001E4 01C8                    	add ax, cx		; (expected not to carry)
   495 000001E6 39D0                    	cmp ax, dx		; end of source is above destination ?
   496 000001E8 58                      	pop ax
   497 000001E9 7730                    	ja .down		; yes, move from top down -->
   498                                  	; Here, the end of source is below-or-equal the destination,
   499                                  	;  so they do not overlap. In this case we prefer moving up.
   500                                  
   501                                  .up:
   502 000001EB 50                      	push ax
   503 000001EC 52                      	push dx
   504                                  .uploop:
   505 000001ED 8ED8                    	mov ds, ax
   506 000001EF 8EC2                    	mov es, dx
   507 000001F1 31FF                    	xor di, di
   508 000001F3 31F6                    	xor si, si		; -> start of segment
   509 000001F5 81E90010                	sub cx, 1000h		; 64 KiB left ?
   510 000001F9 7610                    	jbe .uplast		; no -->
   511 000001FB 51                      	push cx
   512 000001FC B90080                  	mov cx, 10000h /2
   513 000001FF F3A5                    	rep movsw		; move 64 KiB
   514 00000201 59                      	pop cx
   515 00000202 050010                  	add ax, 1000h
   516 00000205 81C20010                	add dx, 1000h		; -> next segment
   517 00000209 EBE2                    	jmp short .uploop	; proceed for more -->
   518                                  .uplast:
   519 0000020B 81C10010                	add cx, 1000h		; restore counter
   520 0000020F D1E1                    	shl cx, 1
   521 00000211 D1E1                    	shl cx, 1
   522 00000213 D1E1                    	shl cx, 1		; *8, paragraphs to words
   523 00000215 F3A5                    	rep movsw		; move last part
   524 00000217 5A                      	pop dx
   525 00000218 58                      	pop ax
   526 00000219 EB43                    	jmp short .return
   527                                  
   528                                  .down:
   529 0000021B FD                      	std			; _AMD_ERRATUM_109_WORKAROUND as below
   530                                  .dnloop:
   531 0000021C 81E90010                	sub cx, 1000h		; 64 KiB left ?
   532 00000220 761A                    	jbe .dnlast		; no -->
   533 00000222 50                      	push ax
   534 00000223 52                      	push dx
   535 00000224 01C8                    	add ax, cx
   536 00000226 01CA                    	add dx, cx
   537 00000228 8ED8                    	mov ds, ax		; -> 64 KiB not yet moved
   538 0000022A 8EC2                    	mov es, dx
   539 0000022C 5A                      	pop dx
   540 0000022D 58                      	pop ax
   541 0000022E BFFEFF                  	mov di, -2
   542 00000231 89FE                    	mov si, di		; moved from last word down
   543 00000233 51                      	push cx
   544 00000234 B90080                  	mov cx, 10000h /2
   545 00000237 F3A5                    	rep movsw		; move 64 KiB
   546 00000239 59                      	pop cx
   547 0000023A EBE0                    	jmp short .dnloop	; proceed for more -->
   548                                  .dnlast:
   549 0000023C 81C10010                	add cx, 1000h		; restore counter
   550 00000240 D1E1                    	shl cx, 1
   551 00000242 D1E1                    	shl cx, 1
   552 00000244 D1E1                    	shl cx, 1		; *8, paragraphs to words
   553 00000246 89CF                    	mov di, cx
   554 00000248 4F                      	dec di
   555 00000249 D1E7                    	shl di, 1		; words to offset, -> last word
   556 0000024B 89FE                    	mov si, di
   557 0000024D 8ED8                    	mov ds, ax
   558 0000024F 8EC2                    	mov es, dx		; first segment correct
   559                                  
   560                                  
   561                                  	numdef AMD_ERRATUM_109_WORKAROUND, 1
   562                                  %if 0
   563                                  
   564                                  Jack R. Ellis pointed out this erratum:
   565                                  
   566                                  Quoting from https://www.amd.com/system/files/TechDocs/25759.pdf page 69:
   567                                  
   568                                  109   Certain Reverse REP MOVS May Produce Unpredictable Behavior
   569                                  
   570                                  Description
   571                                  
   572                                  In certain situations a REP MOVS instruction may lead to
   573                                  incorrect results. An incorrect address size, data size
   574                                  or source operand segment may be used or a succeeding
   575                                  instruction may be skipped. This may occur under the
   576                                  following conditions:
   577                                  
   578                                  * EFLAGS.DF=1 (the string is being moved in the reverse direction).
   579                                  
   580                                  * The number of items being moved (RCX) is between 1 and 20.
   581                                  
   582                                  * The REP MOVS instruction is preceded by some microcoded instruction
   583                                    that has not completely retired by the time the REP MOVS begins
   584                                    execution. The set of such instructions includes BOUND, CLI, LDS,
   585                                    LES, LFS, LGS, LSS, IDIV, and most microcoded x87 instructions.
   586                                  
   587                                  Potential Effect on System
   588                                  
   589                                  Incorrect results may be produced or the system may hang.
   590                                  
   591                                  Suggested Workaround
   592                                  
   593                                  Contact your AMD representative for information on a BIOS update.
   594                                  
   595                                  %endif
   596                                  
   597                                  %if _AMD_ERRATUM_109_WORKAROUND
   598 00000251 E308                    	jcxz @FF
   599 00000253 83F914                  	cmp cx, 20
   600 00000256 7703                    	ja @FF
   601                                  @@:
   602 00000258 A5                      	movsw
   603 00000259 E2FD                    	loop @B
   604                                  @@:
   605                                  %endif
   606 0000025B F3A5                    	rep movsw		; move first part
   607 0000025D FC                      	cld
   608                                  .return:
   609 0000025E C3                      	retn
   610                                  
   611                                  
   612                                  	section PAYLOAD align=16 follows=INIT0
   613                                  payload:
   614 00000000 <bin 12AD5h>            	incbin _PAYLOAD_FILE
   615                                  .end:
   616 00012AD5 26<rep Bh>              	align 16, db 38
   617                                  payload_end:
   618                                  
   619                                  
   620                                  	section INIT1 align=16 follows=PAYLOAD vstart=0
   621                                  init1_start:
   622                                  		; INP:	ax = cs = INIT1
   623                                  		;	dx = cs - (payload_end - payload) >> 4 => source data
   624                                  		;	if kernel mode:
   625                                  		;	 ss:bp -> LOADDATA and LOADSTACKVARS
   626                                  		;	 ss:sp -> valid stack above [bp + ldLoadTop]
   627                                  		;	 60h => destination
   628                                  		;	any mode:
   629                                  		;	 word [ss:sp] = value for ax
   630                                  		;	 bx = 2 if device mode, 1 if EXE mode, 0 if kernel mode
   631                                  		;	 si => destination (60h for kernel mode,
   632                                  		;		after PSP for EXE mode,
   633                                  		;		at device header for device mode)
   634                                  		;		(not set if only kernel mode supported)
   635                                  		;	 if EXE mode:
   636                                  		;	  ss:sp -> valid stack above INIT1
   637                                  		;	  bp = unset
   638                                  		;	 if device mode:
   639                                  		;	  ss:sp -> device entrypoint stack
   640                                  		;	  holds: es, bx, ax, cx, dx, di, si, ds, bp,
   641                                  		;		  far address of payload strategy entrypoint,
   642                                  		;		  far return address to DOS
   643                                  		;	  bp = unset
   644                                  		; STT:	UP
   645                                  		; CHG:	ax, bx, cx, dx, es, ds, si, di
   646                                  %if _IMAGE_EXE || _DEVICE
   647                                  	lframe
   648 00000000 5589E5                  	lenter
   649                                  	lvar word,	exemode		; must be bp - 2!
   650 00000003 53                      	 push bx
   651                                   %if ?exemode != -2
   652                                    %error exemode variable must be directly below bp
   653                                   %endif
   654 00000004 56                      	push si
   655                                  %else
   656                                  	xor bx, bx		; always tell them it is kernel mode
   657                                  %endif
   658                                  
   659                                  %if _IMAGE_EXE
   660 00000005 8EC6                    	mov es, si		; es => destination
   661                                  %else
   662                                  	mov ax, 60h
   663                                  	mov es, ax		; es => destination
   664                                  %endif
   665 00000007 31FF                    	xor di, di		; -> destination
   666                                  
   667 00000009 8EDA                    	mov ds, dx
   668 0000000B 31F6                    	xor si, si		; -> source
   669                                  
   670 0000000D B9D52A                  	mov cx, (payload.end - payload) & 0FFFFh
   671                                  %if (payload.end - payload) >> 16
   672 00000010 BA0100                  	mov dx, (payload.end - payload) >> 16	; = length of source
   673                                  %else
   674                                  	xor dx, dx
   675                                  %endif
   676                                  %if _PAYLOAD_KERNEL_MAX_PARAS
   677                                  	mov ax, _PAYLOAD_KERNEL_MAX_PARAS
   678                                  	test bx, bx
   679                                  	jz @F
   680                                  %endif
   681 00000013 B8FFFF                  	mov ax, -1
   682                                  @@:
   683                                  		; INP:	ds:si -> source
   684                                  		;	dx:cx = length of source
   685                                  		;	es:di -> destination (below source)
   686                                  		;	bx = EXE mode flag
   687                                  		;	 (1 if EXE mode, 0 if kernel mode)
   688                                  		;	 (always 0 if this is a build without EXE mode)
   689                                  		;	if _PAYLOAD_KERNEL_MAX_PARAS:
   690                                  		;	 ax = maximum amount in paragraphs of destination needed
   691                                  		;	 (-1 if full source should be decompressed)
   692                                  		;	else:
   693                                  		;	 ax = -1
   694                                  		; Note:	The destination reaches up to below the source.
   695 00000016 E80201                  	call depack
   696                                  %ifn _TEST_PROGRAM
   697                                  	jc strict short error
   698                                  %endif
   699                                  %if _IMAGE_EXE
   700 00000019 5E                      	pop si			; si
   701                                   %if _TEST_PROGRAM
   702 0000001A 58                      	pop ax			; (discard ?exemode, leave bx as returned)
   703                                   %else
   704                                  	pop bx			; ?exemode
   705                                   %endif
   706 0000001B 5D                      	pop bp			; bp
   707 0000001C 58                      	pop ax			; ax
   708                                  	lleave ctx
   709                                  %endif
   710                                  %if _TEST_PROGRAM
   711 0000001D CB                      	retf
   712 0000001E 90                      	nop
   713                                  %endif
   714                                  
   715                                  %if _DEVICE
   716 0000001F F6C302                  	test bl, 2
   717 00000022 7411                    	jz .jmp_exe_or_kernel_mode
   718                                  
   719                                  .jmp_device_mode:
   720 00000024 8EDE                    	mov ds, si
   721 00000026 830E[0000]FF            	or word [device_header.next], -1
   722 0000002B 07                      	pop es
   723 0000002C 5B                      	pop bx
   724 0000002D 58                      	pop ax
   725 0000002E 59                      	pop cx
   726 0000002F 5A                      	pop dx
   727 00000030 5F                      	pop di
   728 00000031 5E                      	pop si
   729 00000032 1F                      	pop ds
   730 00000033 5D                      	pop bp
   731 00000034 CB                      	retf			; transfer to payload strategy entrypoint
   732                                  				; still on stack: far return address to DOS
   733                                  
   734                                  .jmp_exe_or_kernel_mode:
   735                                  %endif
   736                                  
   737                                  %if _IMAGE_EXE
   738 00000035 F6C301                  	test bl, 1
   739 00000038 7410                    	jz .jmp_kernel_mode
   740                                  
   741                                  .jmp_exe_mode:
   742                                  %if ! _IMAGE_EXE_AUTO_STACK
   743                                  	mov cx, cs
   744                                  	lea dx, [si + _IMAGE_EXE_SS]
   745                                  	push dx			; stack = relocated ss value
   746                                  	add dx, (_IMAGE_EXE_SP + 2 + 15) >> 4
   747                                  	cmp cx, dx		; INIT1 code is above intended stack ?
   748                                  	jae @F			; yes -->
   749                                  
   750                                  	lframe
   751                                  	lenter
   752                                  	lvar	word, exemode
   753                                  	 push bx
   754                                   %if ?exemode != -2
   755                                    %error exemode variable must be directly below bp
   756                                   %endif
   757                                  	mov bx, -1		; unimplemented, return error
   758                                  	jmp error
   759                                  	lleave ctx
   760                                  @@:
   761                                  	cli
   762                                  	pop ss			; = relocated ss value
   763                                  	mov sp, (_IMAGE_EXE_SP + 2) & 0FFFFh	; change stack
   764                                  	sti
   765                                  %endif
   766                                  
   767 0000003A 31C9                    	xor cx, cx
   768 0000003C 51                      	push cx			; put zero on top of stack
   769                                  
   770                                  %if _IMAGE_EXE_IP < 256
   771                                  	mov cl, _IMAGE_EXE_IP
   772                                  %elif (_IMAGE_EXE_IP & 255) == 0
   773                                  	mov ch, _IMAGE_EXE_IP >> 8
   774                                  %else
   775 0000003D B94001                  	mov cx, _IMAGE_EXE_IP
   776                                  %endif
   777                                  
   778                                  %if _IMAGE_EXE_CS == -16
   779 00000040 83C6F0                  	add si, -16
   780 00000043 8EDE                    	mov ds, si
   781 00000045 8EC6                    	mov es, si
   782                                  %else
   783                                  	lea dx, [si - 10h]	; => PSP
   784                                  	mov ds, dx
   785                                  	mov es, dx		; ds = es => PSP
   786                                  	add si, _IMAGE_EXE_CS	; = relocated cs value
   787                                  %endif
   788 00000047 56                      	push si
   789 00000048 51                      	push cx
   790 00000049 CB                      	retf			; jump to EXE mode of image
   791                                  
   792                                  %endif
   793                                  .jmp_kernel_mode:
   794 0000004A EA20006000              	jmp 60h + _EXEC_SEGMENT:_EXEC_OFFSET
   795                                  
   796                                  
   797                                  error:
   798 0000004F 0E                      	push cs
   799 00000050 1F                      	pop ds
   800                                  %if _DEBUG0
   801                                  	mov si, msg.error_begin
   802                                  	call disp_error
   803                                  	xchg ax, bx			; ax = error code
   804                                  	call disp_ax_hex
   805                                  	mov si, msg.error_end
   806                                  %else
   807 00000051 BE[F600]                	mov si, msg.error
   808                                  %endif
   809 00000054 E87D00                  	call disp_error
   810                                  
   811                                  %if _DEVICE
   812 00000057 F646FE02                	test byte [bp - 2], 2
   813 0000005B 7435                    	jz .exit_app_or_kernel
   814                                  
   815 0000005D 5E                      	pop si				; => device segment
   816 0000005E 5B                      	pop bx				; mode word
   817 0000005F 5D                      	pop bp
   818 00000060 58                      	pop ax
   819 00000061 8EC6                    	mov es, si
   820 00000063 31FF                    	xor di, di			; -> device header
   821 00000065 0E                      	 push cs
   822 00000066 1F                      	 pop ds
   823 00000067 BE[B000]                	mov si, device_header_copy	; -> to reset header
   824 0000006A B91100                  	mov cx, words(device_header_copy.length)
   825 0000006D F3A5                    	rep movsw		; overwrite device header with default
   826                                  				;  (reset to a valid state after unsuccessful
   827                                  				;  decompression, which may have partially
   828                                  				;  written the header already)
   829 0000006F 06                      	 push es
   830 00000070 1F                      	 pop ds				; -> device segment
   831 00000071 07                      	pop es
   832 00000072 5B                      	pop bx
   833 00000073 26C747030381            	mov word [es:bx + 3], 8103h	; set error, done, invalid command
   834 00000079 26C6470D00              	mov byte [es:bx + 13], 0	; set number of units = 0
   835 0000007E 268C5F10                	mov word [es:bx + 14 + 2], ds
   836 00000082 2683670E00              	and word [es:bx + 14], 0	; -> after end of memory to allocate
   837 00000087 58                      	pop ax
   838 00000088 59                      	pop cx
   839 00000089 5A                      	pop dx
   840 0000008A 5F                      	pop di
   841 0000008B 5E                      	pop si
   842 0000008C 1F                      	pop ds
   843 0000008D 5D                      	pop bp
   844 0000008E 83C404                  	add sp, 4		; discard far return to payload's strategy
   845 00000091 CB                      	retf			; return to DOS
   846                                  
   847                                  
   848                                  .exit_app_or_kernel:
   849                                  %endif
   850                                  
   851                                  %if _IMAGE_EXE
   852 00000092 F646FE01                	test byte [bp - 2], 1
   853 00000096 7405                    	jz .exit_kernel_mode
   854                                  
   855 00000098 B87F4C                  	mov ax, 4C7Fh
   856 0000009B CD21                    	int 21h
   857                                  
   858                                  .exit_kernel_mode:
   859                                  %endif
   860 0000009D 31C0                    	xor ax, ax
   861 0000009F CD16                    	int 16h
   862 000000A1 CD19                    	int 19h
   863                                  
   864                                  
   865                                  %if _DEVICE
   866 000000A3 90<rep Dh>              	align 16
   867                                  device_header_copy:
   868                                  .:
   869                                  .next:
   870 000000B0 FFFFFFFF                	dd -1				; already initialised
   871                                  .attributes:
   872 000000B4 0080                    	dw _DEVICE_ATTRIBUTE
   873                                  .strategy:
   874 000000B6 1200                    	dw .strategy_entry - .		; -> strategy entry
   875                                  .interrupt:
   876 000000B8 1600                    	dw .interrupt_entry - .		; -> interrupt entry
   877                                  .name:
   878 000000BA 4C44454255472424        	fill 8, 32, db _DEVICE_NAME
   879                                  .strategy_entry:
   880 000000C2 EB0690<rep 2h>          	fill 4, 90h, jmp .set_error	; rel8 or rel16 jump, not minus .
   881                                  .interrupt_entry:
   882 000000C6 CB90<rep 3h>            	fill 4, 90h, retf
   883                                  
   884                                  .set_error:
   885 000000CA 26C747030381            	mov word [es:bx + 3], 8103h	; set error, done, invalid command
   886 000000D0 CB                      	retf
   887                                  .length: equ $ - .
   888                                  %endif
   889                                  
   890                                  
   891                                  disp_error.loop:
   892 000000D1 E80600                  	call disp_al
   893                                  disp_error:
   894 000000D4 AC                      	lodsb
   895 000000D5 84C0                    	test al, al
   896 000000D7 75F8                    	jnz .loop
   897 000000D9 C3                      	retn
   898                                  
   899                                  %if _DEBUG0 || _DEBUG1 || _DEBUG2 || _DEBUG3
   900                                  disp_ax_hex:			; ax
   901                                  		xchg al,ah
   902                                  		call disp_al_hex		; display former ah
   903                                  		xchg al,ah			;  and fall trough for al
   904                                  disp_al_hex:			; al
   905                                  		push cx
   906                                  		mov cl,4
   907                                  		ror al,cl
   908                                  		call disp_al_lownibble_hex	; display former high-nibble
   909                                  		rol al,cl
   910                                  		pop cx
   911                                  						;  and fall trough for low-nibble
   912                                  disp_al_lownibble_hex:
   913                                  		push ax			 ; save ax for call return
   914                                  		and al,00001111b		; high nibble must be zero
   915                                  		add al,'0'			; if number is 0-9, now it's the correct character
   916                                  		cmp al,'9'
   917                                  		jna .decimalnum		 ; if we get decimal number with this, ok -->
   918                                  		add al,7			;  otherwise, add 7 and we are inside our alphabet
   919                                   .decimalnum:
   920                                  		call disp_al
   921                                  		pop ax
   922                                  		retn
   923                                  %endif
   924                                  
   925                                  disp_al:
   926                                  %if _TEST_PROGRAM
   927 000000DA C3                      	retn
   928                                  %else
   929                                  	push ax
   930                                  %endif
   931 000000DB 53                      	push bx
   932 000000DC 55                      	push bp
   933 000000DD B40E                    	mov ah, 0Eh
   934 000000DF BB0700                  	mov bx, 7
   935                                  %if _IMAGE_EXE || _DEVICE
   936 000000E2 52                      	push dx
   937                                  
   938 000000E3 F646FE03                	test byte [bp - 2], 1 | 2
   939 000000E7 7406                    	jz .display_kernel_mode
   940                                  
   941 000000E9 92                      	xchg dx, ax				; dl = input al
   942 000000EA B402                    	mov ah, 02h
   943 000000EC CD21                    	int 21h
   944 000000EE A9                      	db __TEST_IMM16				; (skip int)
   945                                  
   946                                  .display_kernel_mode:
   947                                  %endif
   948 000000EF CD10                    	int 10h
   949                                  %if _IMAGE_EXE
   950 000000F1 5A                      	pop dx
   951                                  %endif
   952 000000F2 5D                      	pop bp
   953 000000F3 5B                      	pop bx
   954 000000F4 58                      	pop ax
   955                                  disp_error.ret:
   956 000000F5 C3                      	retn
   957                                  
   958                                  
   959                                  msg:
   960                                  %if _DEBUG0
   961                                  .error_begin:	db "Load error: Decompression failure, code ",0
   962                                  .error_end:	db "h.",13,10,0
   963                                  %else
   964 000000F6 4C6F6164206572726F-     .error:		db "Load error: Decompression failure.",13,10,0
   964 000000FF 723A204465636F6D70-
   964 00000108 72657373696F6E2066-
   964 00000111 61696C7572652E0D0A-
   964 0000011A 00                 
   965                                  %endif
   966                                  
   967                                  
   968                                  %assign NEED_NORMALISE_POINTER_WITH_DISPLACEMENT 1
   969                                  %assign CHECK_POINTERS_VARIABLE_SRC 1
   970                                  %assign CHECK_POINTERS_VARIABLE_DST 1
   971                                  
   972                                  		; Specific depacker's file is included within label msg.
   973                                  		; In the file, lframe is used and lleave ctx is not used.
   974                                  
   975                                  %if _BRIEFLZ
   976                                  	%include "brieflz.asm"
   977                                  %endif
   978                                  
   979                                  
   980                                  %if _LZ4
   981                                  	%include "lz4.asm"
   982                                  %endif
   983                                  
   984                                  
   985                                  %if _SNAPPY
   986                                  	%include "snappy.asm"
   987                                  %endif
   988                                  
   989                                  
   990                                  %if _EXODECR
   991                                  	%include "exodecr.asm"
     1                              <1> 
     2                              <1> %if 0
     3                              <1> 
     4                              <1> 8086 Assembly lDOS iniload payload exomizer raw depacker
     5                              <1>  by C. Masloch, 2020
     6                              <1> 
     7                              <1> Copyright (c) 2005-2017 Magnus Lind.
     8                              <1> 
     9                              <1> This software is provided 'as-is', without any express or implied warranty.
    10                              <1> In no event will the authors be held liable for any damages arising from
    11                              <1> the use of this software.
    12                              <1> 
    13                              <1> Permission is granted to anyone to use this software for any purpose,
    14                              <1> including commercial applications, and to alter it and redistribute it
    15                              <1> freely, subject to the following restrictions:
    16                              <1> 
    17                              <1>   1. The origin of this software must not be misrepresented * you must not
    18                              <1>   claim that you wrote the original software. If you use this software in a
    19                              <1>   product, an acknowledgment in the product documentation would be
    20                              <1>   appreciated but is not required.
    21                              <1> 
    22                              <1>   2. Altered source versions must be plainly marked as such, and must not
    23                              <1>   be misrepresented as being the original software.
    24                              <1> 
    25                              <1>   3. This notice may not be removed or altered from any distribution.
    26                              <1> 
    27                              <1>   4. The names of this software and/or it's copyright holders may not be
    28                              <1>   used to endorse or promote products derived from this software without
    29                              <1>   specific prior written permission.
    30                              <1> 
    31                              <1> %endif
    32                              <1> 
    33                              <1> 	numdef P, 7, 7
    34                              <1> 
    35                              <1> 
    36                              <1> 	struc exo_table_entry
    37 00000000 ??                  <1> eteBits:	resb 1
    38 00000001 ????                <1> eteBase:	resw 1
    39                              <1> 	endstruc
    40                              <1> 
    41                              <1> 		; INP:	ds:si -> source
    42                              <1> 		;	dx:cx = length of source
    43                              <1> 		;	es:di -> destination (below source)
    44                              <1> 		;	if _IMAGE_EXE:
    45                              <1> 		;	 bx = EXE mode flag (bit 0)
    46                              <1> 		;	else:
    47                              <1> 		;	 bx = 0
    48                              <1> 		;	if _PAYLOAD_KERNEL_MAX_PARAS:
    49                              <1> 		;	 ax = maximum amount in paragraphs of destination needed
    50                              <1> 		;	 (-1 if full source should be decompressed)
    51                              <1> 		;	else:
    52                              <1> 		;	 ax = -1
    53                              <1> 		; OUT:	NC if success
    54                              <1> 		;	CY if error,
    55                              <1> 		;	 bx = ?errordata (if _DEBUG0)
    56                              <1> 		; CHG:	ax, (bx), cx, dx, es, ds, si, di
    57                              <1> 		; STT:	UP
    58                              <1> 		;
    59                              <1> 		; Note:	The destination reaches up to below the source.
    60                              <1> 		; Note:	The input pointers need not be normalised yet.
    61                              <1> 		;	 Normalised means that the offset part is below 16.
    62                              <1> depack:
    63                              <1> 	lframe near
    64 0000011B 5589E5              <1> 	lenter
    65                              <1>  %if _IMAGE_EXE
    66                              <1> 	lvar word,	exemode	; must be bp - 2!
    67 0000011E 53                  <1> 	 push bx
    68                              <1>   %if ?exemode != -2
    69                              <1>    %error exemode variable must be directly below bp
    70                              <1>   %endif
    71                              <1>  %endif
    72 0000011F 31DB                <1> 	xor bx, bx
    73                              <1>  %if _DEBUG0
    74                              <1> 	lvar word,	errordata
    75                              <1> 	 push bx
    76                              <1>  %endif
    77                              <1> 	lvar word, bit_buffer_and_counter
    78                              <1> 	lequ ?bit_buffer_and_counter, bit_buffer
    79                              <1> 	lequ ?bit_buffer_and_counter + 1, counter
    80 00000121 53                  <1> 	 push bx		; initialise counter (high byte) to zero
    81                              <1> 				; if _P & 8: initialise bit_buffer to zero
    82                              <1> 
    83 00000122 E84402              <1> 	call normalise_both_pointers
    84                              <1> 
    85                              <1> 	lvar dword,	src
    86 00000125 1E                  <1> 	 push ds
    87 00000126 56                  <1> 	 push si
    88                              <1> 	lvar dword,	original_dst
    89 00000127 06                  <1> 	 push es
    90 00000128 57                  <1> 	 push di
    91                              <1> 	lvar dword,	dst
    92 00000129 06                  <1> 	 push es
    93 0000012A 57                  <1> 	 push di
    94                              <1> 	lvar dword,	src_remaining
    95 0000012B 52                  <1> 	 push dx
    96 0000012C 51                  <1> 	 push cx
    97                              <1> 
    98                              <1> %if _PAYLOAD_KERNEL_MAX_PARAS
    99                              <1> 	cmp ax, -1		; no maximum specified ?
   100                              <1> 	je @FF			; retain -1 in ax -->
   101                              <1> 	test di, di		; do we need an additional paragraph ?
   102                              <1> 	jz @F			; no -->
   103                              <1> 	inc ax			; es + ax => paragraph after necessary part
   104                              <1> @@:
   105                              <1> 	mov dx, es
   106                              <1> 	add ax, dx		; => paragraph after necessary part
   107                              <1> 		; If the normalised destination pointer's segment grows
   108                              <1> 		;  to this segment then enough has been decompressed.
   109                              <1> d0	mov byte [bp + ?errordata], 40h
   110                              <1> 	jc .error		; should not carry
   111                              <1> @@:
   112                              <1> 	lvar word,	dst_max_segment
   113                              <1> 	 push ax
   114                              <1> %endif
   115                              <1> 
   116 0000012D 1E                  <1> 	 push ds
   117 0000012E 56                  <1> 	 push si
   118 0000012F E89702              <1> 	call pointer_to_linear
   119                              <1> 
   120 00000132 89D3                <1> 	mov bx, dx
   121 00000134 91                  <1> 	xchg cx, ax		; bx:cx = source linear
   122                              <1> 
   123 00000135 06                  <1> 	 push es
   124 00000136 57                  <1> 	 push di
   125 00000137 E88F02              <1> 	call pointer_to_linear
   126                              <1> 
   127                              <1> %if _ALLOW_OVERLAPPING
   128 0000013A 034EEC              <1> 	add cx, word [bp + ?src_remaining]
   129 0000013D 135EEE              <1> 	adc bx, word [bp + ?src_remaining + 2]
   130                              <1> 		; In case of allowing overlapping source and destination,
   131                              <1> 		;  the ?dst_remaining variable is set to
   132                              <1> 		;  ?src + ?src_remaining - ?dst, allowing to write to
   133                              <1> 		;  all of the source buffer (with the checks already in place
   134                              <1> 		;  from the default handling). Additional checks are done by
   135                              <1> 		;  calling check_pointers_not_overlapping. This is done after
   136                              <1> 		;  every change of ?dst to verify that the write pointer stays
   137                              <1> 		;  below-or-equal the read pointer.
   138                              <1> 		; This means the remaining source data may be corrupted by a
   139                              <1> 		;  write, but nothing after the source data is written to,
   140                              <1> 		;  so the error handling (in INIT1 after the data) still works.
   141                              <1> %endif
   142                              <1> 
   143 00000140 29C1                <1> 	sub cx, ax
   144 00000142 19D3                <1> 	sbb bx, dx		; bx:cx = source linear - destination linear
   145                              <1> 
   146                              <1> 	lvar dword,	dst_remaining
   147 00000144 53                  <1> 	 push bx		; push into [bp + ?dst_remaining + 2]
   148 00000145 51                  <1> 	 push cx		; push into [bp + ?dst_remaining]
   149                              <1> 
   150                              <1> %if _ALLOW_OVERLAPPING
   151 00000146 E80402              <1> 	call check_pointers_not_overlapping
   152                              <1> 		; Note:	We initially check here that the write pointer is
   153                              <1> 		;	 low enough, ie below-or-equal the read pointer.
   154                              <1> 		;	 Doing this check here (as well as after any
   155                              <1> 		;	 copied match) allows us to drop the check done
   156                              <1> 		;	 after moving literal bytes.
   157                              <1> d0	mov byte [bp + ?errordata], 1Bh
   158 00000149 7303E93B01          <1> 	jc .error
   159                              <1> %endif
   160                              <1> 
   161                              <1> 	lequ fromwords(words(16 * exo_table_entry_size)), 16tablesize
   162                              <1> 	lvar ?16tablesize, lengths
   163                              <1> %if _P & 16
   164                              <1> 	lvar ?16tablesize, offsets4
   165                              <1> %endif
   166                              <1> 	lvar ?16tablesize, offsets3
   167                              <1> 	lvar ?16tablesize, offsets2
   168                              <1> 	lequ fromwords(words(4 * exo_table_entry_size)), 4tablesize
   169                              <1> 	lvar ?4tablesize, offsets1
   170 0000014E 8DA64CFF            <1> 	lreserve
   171                              <1> 
   172                              <1> %ifn _P & 8
   173 00000152 E85101              <1> 	call read_byte_to_bit_buffer
   174                              <1> d0	mov byte [bp + ?errordata], 30h
   175 00000155 7303E92F01          <1> 	jc .error
   176                              <1> %endif
   177                              <1> 
   178 0000015A BFB8FF              <1> 	mov di, ?lengths
   179 0000015D E88C01              <1> 	call generate_table_16
   180                              <1> d0	mov byte [bp + ?errordata], 41h
   181 00000160 7303E92401          <1> 	jc .error
   182                              <1> %if _P & 16
   183                              <1> 	mov di, ?offsets4
   184                              <1> 	call generate_table_16
   185                              <1> d0	mov byte [bp + ?errordata], 49h
   186                              <1> 	jc .error
   187                              <1> %endif
   188 00000165 BF88FF              <1> 	mov di, ?offsets3
   189 00000168 E88101              <1> 	call generate_table_16
   190                              <1> d0	mov byte [bp + ?errordata], 42h
   191 0000016B 7303E91901          <1> 	jc .error
   192 00000170 BF58FF              <1> 	mov di, ?offsets2
   193 00000173 E87601              <1> 	call generate_table_16
   194                              <1> d0	mov byte [bp + ?errordata], 43h
   195 00000176 7303E90E01          <1> 	jc .error
   196 0000017B BF4CFF              <1> 	mov di, ?offsets1
   197 0000017E B104                <1> 	mov cl, 4
   198 00000180 E86C01              <1> 	call generate_table_cx		; cx = 0 if NC
   199                              <1> d0	mov byte [bp + ?errordata], 44h
   200 00000183 7303E90101          <1> 	jc .error
   201                              <1> 
   202                              <1> %ifn _P & 4
   203                              <1> 	jmp .STATE_NEXT_BYTE
   204                              <1> %endif
   205                              <1> 
   206                              <1> 		; cx = 0
   207                              <1> .STATE_IMPLICIT_FIRST_LITERAL_BYTE:
   208                              <1> 		; ! cx = 0
   209                              <1> 		; All paths to this label must have cx = 0.
   210                              <1> .literal:
   211 00000188 41                  <1> 	inc cx				; cx = 1
   212                              <1> .STATE_NEXT_LITERAL_BYTE_increment_counter:
   213 00000189 C576F8              <1> 	lds si, [bp + ?src]
   214 0000018C 294EEC              <1> 	sub word [bp + ?src_remaining], cx
   215 0000018F 835EEE00            <1> 	sbb word [bp + ?src_remaining + 2], 0
   216                              <1> d0	mov byte [bp + ?errordata], 45h
   217 00000193 7303E9F100          <1> 	jc .error
   218 00000198 E88601              <1> 	call copy_data
   219                              <1> d0	mov byte [bp + ?errordata], 46h
   220 0000019B 7303E9E900          <1> 	jc .error
   221 000001A0 8976F8              <1> 	mov word [bp + ?src], si
   222 000001A3 8C5EFA              <1> 	mov word [bp + ?src + 2], ds
   223                              <1> 
   224                              <1> 		; cx = 0
   225                              <1> 	; jmp .STATE_NEXT_BYTE
   226                              <1> 
   227                              <1> .STATE_NEXT_BYTE:
   228                              <1> %if _COUNTER
   229                              <1> 	inc byte [bp + ?counter]
   230                              <1> 	test byte [bp + ?counter], _COUNTER - 1
   231                              <1> 	jnz @F
   232                              <1> 	mov al, '.'
   233                              <1> 	call disp_al
   234                              <1> @@:
   235                              <1> %endif
   236 000001A6 E80E01              <1> 	call read_bits_1		; cx = 0 if NC
   237                              <1> d0	mov byte [bp + ?errordata], 32h
   238 000001A9 7303E9DB00          <1> 	jc .error
   239 000001AE 85C0                <1> 	test ax, ax
   240 000001B0 75D6                <1> 	jnz .literal			; (cx = 0 still)
   241                              <1> 
   242                              <1> 		; cx = ax = 0
   243                              <1> .not_literal:
   244                              <1> 
   245                              <1> 	; call get_gamma_code
   246                              <1> 		; INP:	-
   247                              <1> 		; OUT:	CY if error
   248                              <1> 		;	NC if success,
   249                              <1> 		;	 bx:dx = gamma
   250                              <1> 		;	 ax = cx = 0
   251                              <1> 		; CHG:	ds, si
   252                              <1> 		; STT:	bp -> depack stack frame
   253                              <1> 		;	UP
   254                              <1> .get_gamma_code:
   255 000001B2 31D2                <1> 	xor dx, dx
   256 000001B4 31DB                <1> 	xor bx, bx		; bx:dx = gamma = 0
   257                              <1> .ggc_loop:
   258                              <1> 		; cx = 0. ax = 0 initially, else = 1
   259 000001B6 01C2                <1> 	add dx, ax
   260 000001B8 11CB                <1> 	adc bx, cx		; ++gamma (except initially)
   261 000001BA E8FA00              <1> 	call read_bits_1	; read_bits(1)
   262                              <1> d0	mov byte [bp + ?errordata], 33h
   263 000001BD 7303E9C700          <1> 	jc .error
   264 000001C2 3401                <1> 	xor al, 1		; returned == 0 ?
   265 000001C4 75F0                <1> 	jnz .ggc_loop		; yes, loop --> (ax = 1 if looping)
   266                              <1> 				; no, end of loop
   267                              <1> 
   268 000001C6 85DB                <1> 	test bx, bx
   269                              <1> d0	mov byte [bp + ?errordata], 34h
   270 000001C8 7403E9BC00          <1> 	jnz .error
   271 000001CD 83FA11              <1> 	cmp dx, 17
   272 000001D0 7515                <1> 	jne .not_literal_data_block
   273                              <1> .literal_data_block:
   274                              <1> %if _P & 2
   275 000001D2 E8B900              <1> 	call read_byte
   276                              <1> d0	mov byte [bp + ?errordata], 35h
   277 000001D5 7303E9AF00          <1> 	jc .error
   278 000001DA 88C4                <1> 	mov ah, al
   279 000001DC E8AF00              <1> 	call read_byte
   280                              <1> d0	mov byte [bp + ?errordata], 36h
   281 000001DF 7303E9A500          <1> 	jc .error
   282                              <1> %else
   283                              <1> 	mov cx, 16
   284                              <1> 	call read_bits
   285                              <1> d0	mov byte [bp + ?errordata], 48h
   286                              <1> 	jc .error
   287                              <1> %endif
   288 000001E4 91                  <1> 	xchg ax, cx
   289 000001E5 EBA2                <1> 	jmp .STATE_NEXT_LITERAL_BYTE_increment_counter
   290                              <1> 
   291                              <1> .not_literal_data_block:
   292 000001E7 83FA10              <1> 	cmp dx, 16
   293 000001EA 7503E98D00          <1> 	je .end_check
   294                              <1> d0	mov byte [bp + ?errordata], 38h
   295 000001EF 7603E99500          <1> 	ja .error
   296                              <1> 
   297                              <1> .sequence:
   298 000001F4 89D7                <1> 	mov di, dx
   299 000001F6 01D2                <1> 	add dx, dx
   300 000001F8 01D7                <1> 	add di, dx		; * 3 = * exo_table_entry_size
   301                              <1> 
   302 000001FA 8B5BB9              <1> 	mov bx, word [bp + ?lengths + di + eteBase]
   303                              <1> 	; xor cx, cx		; cx = 0 already after get_gamma_code NC
   304 000001FD 8A4BB8              <1> 	mov cl, byte [bp + ?lengths + di + eteBits]
   305 00000200 E8B700              <1> 	call read_bits		; cx = 0 if NC
   306                              <1> d0	mov byte [bp + ?errordata], 39h
   307 00000203 7303E98100          <1> 	jc .error
   308 00000208 01C3                <1> 	add bx, ax		; bx = length
   309 0000020A 85DB                <1> 	test bx, bx
   310 0000020C 7413                <1> 	jz .switch_default
   311 0000020E 83FB02              <1> 	cmp bx, 2
   312 00000211 7409                <1> 	je .switch_case2
   313                              <1> %ifn _P & 16
   314 00000213 770C                <1> 	ja .switch_default
   315                              <1> %else
   316                              <1> 	jb .switch_case1
   317                              <1> 	cmp bx, 4
   318                              <1> 	jb .switch_case3
   319                              <1> 	jmp .switch_default
   320                              <1> %endif
   321                              <1> .switch_case1:
   322 00000215 B102                <1> 	mov cl, 2		; cx = 2
   323 00000217 BA4CFF              <1> 	mov dx, ?offsets1
   324                              <1> d0	mov byte [bp + ?errordata], 3Ah
   325 0000021A EB0A                <1> 	jmp .switch_common
   326                              <1> 
   327                              <1> .switch_case2:
   328 0000021C BA58FF              <1> 	mov dx, ?offsets2
   329                              <1> d0	mov byte [bp + ?errordata], 3Bh
   330 0000021F EB03                <1> 	jmp .switch_common_cl_4
   331                              <1> 
   332                              <1> %ifn _P & 16
   333                              <1> .switch_default:
   334 00000221 BA88FF              <1> 	mov dx, ?offsets3
   335                              <1> d0	mov byte [bp + ?errordata], 3Ch
   336                              <1> %else
   337                              <1> .switch_case3:
   338                              <1> 	mov dx, ?offsets3
   339                              <1> d0	mov byte [bp + ?errordata], 4Ah
   340                              <1> 	jmp .switch_common_cl_4
   341                              <1> 
   342                              <1> .switch_default:
   343                              <1> 	mov dx, ?offsets4
   344                              <1> d0	mov byte [bp + ?errordata], 4Bh
   345                              <1> %endif
   346                              <1> 	; jmp .switch_common_cl_4
   347                              <1> 
   348                              <1> .switch_common_cl_4:
   349 00000224 B104                <1> 	mov cl, 4		; cx = 4
   350                              <1> 
   351                              <1> .switch_common:
   352 00000226 E89100              <1> 	call read_bits
   353 00000229 725E                <1> 	jc .error
   354                              <1> 				; ax = next index, dx -> next table
   355 0000022B 89C7                <1> 	mov di, ax
   356 0000022D 01C0                <1> 	add ax, ax
   357 0000022F 01C7                <1> 	add di, ax		; di = offset into table
   358 00000231 01D7                <1> 	add di, dx		; -> table entry
   359                              <1> 	; xor cx, cx		; cx already = 0 after read_bits NC
   360 00000233 8A0B                <1> 	mov cl, byte [bp + di + eteBits]
   361 00000235 E88200              <1> 	call read_bits		; leaves cx = 0 if NC
   362                              <1> d0	mov byte [bp + ?errordata], 3Dh
   363 00000238 724F                <1> 	jc .error
   364 0000023A 87CB                <1> 	xchg cx, bx		; cx = length that we remembered in bx
   365                              <1> 				; bx = 0
   366 0000023C 92                  <1> 	xchg dx, ax		; bx:dx = read bits
   367                              <1> 
   368 0000023D 035301              <1> 	add dx, word [bp + di + eteBase]
   369 00000240 83D300              <1> 	adc bx, 0		; bx:dx = offset
   370                              <1> 
   371                              <1> 	; test bx, bx		; offset 0 ?
   372 00000243 7504                <1> 	jnz @F			; no -->
   373 00000245 85D2                <1> 	test dx, dx		; offset 0 ?
   374                              <1> d0	mov byte [bp + ?errordata], 3Eh
   375 00000247 7440                <1> 	jz .error		; yes, invalid -->
   376                              <1> @@:
   377 00000249 51                  <1> 	push cx
   378 0000024A 89D1                <1> 	mov cx, dx
   379 0000024C F7DB                <1>         neg bx
   380 0000024E F7D9                <1>         neg cx
   381 00000250 83DB00              <1>         sbb bx, byte 0          ; neg bx:cx
   382 00000253 FF76F2              <1> 	 push word [bp + ?dst + 2]
   383 00000256 FF76F0              <1> 	 push word [bp + ?dst]
   384 00000259 E83E01              <1> 	call normalise_pointer_with_displacement_bxcx
   385 0000025C 5E                  <1> 	 pop si
   386 0000025D 5B                  <1> 	 pop bx			; bx:si = pointer into decompressed data
   387 0000025E 59                  <1> 	pop cx			; restore match length
   388                              <1> d0	mov byte [bp + ?errordata], 47h
   389 0000025F 7328                <1> 	jnc .error
   390                              <1> 
   391 00000261 395EF6              <1> 	cmp word [bp + ?original_dst + 2], bx
   392                              <1> 				; is source of matching within ?dst ?
   393                              <1> d0	mov byte [bp + ?errordata], 16h
   394 00000264 7723                <1> 	ja .error
   395 00000266 7205                <1> 	jb @F
   396 00000268 3976F4              <1> 	cmp word [bp + ?original_dst], si
   397                              <1> d0	mov byte [bp + ?errordata], 17h
   398 0000026B 771C                <1> 	ja .error		; no, ?original_dst is above it -->
   399                              <1> @@:
   400 0000026D 8EDB                <1> 	mov ds, bx		; -> match source data
   401 0000026F E8AF00              <1> 	call copy_data
   402                              <1> d0	mov byte [bp + ?errordata], 3Fh
   403 00000272 7215                <1> 	jc .error
   404                              <1> 
   405                              <1> %if _ALLOW_OVERLAPPING
   406 00000274 E8D600              <1> 	call check_pointers_not_overlapping
   407                              <1> d0	mov byte [bp + ?errordata], 1Ch
   408 00000277 7210                <1> 	jc .error
   409                              <1> %endif
   410 00000279 E92AFF              <1> 	jmp .STATE_NEXT_BYTE
   411                              <1> 
   412                              <1> .end_check:
   413                              <1> d0	mov byte [bp + ?errordata], 40h
   414 0000027C 837EEE00            <1> 	cmp word [bp + ?src_remaining + 2], 0
   415 00000280 7507                <1> 	jne .error
   416 00000282 837EEC0F            <1> 	cmp word [bp + ?src_remaining], 15
   417 00000286 7701                <1> 	ja .error
   418                              <1> .end:
   419 00000288 A8                  <1> 	db __TEST_IMM8			; (NC)
   420                              <1> .error:
   421 00000289 F9                  <1> 	stc
   422                              <1> 
   423                              <1> %if _COUNTER
   424                              <1> 	lahf
   425                              <1> 	mov al, 13
   426                              <1> 	call disp_al
   427                              <1> 	mov al, 10
   428                              <1> 	call disp_al
   429                              <1> 	sahf
   430                              <1> %endif
   431                              <1> d0	mov bx, word [bp + ?errordata]
   432 0000028A 89EC5D              <1> 	lleave code
   433 0000028D C3                  <1> 	lret
   434                              <1> 
   435                              <1> 
   436                              <1> 		; INP:	?src
   437                              <1> 		;	?src_remaining
   438                              <1> 		; OUT:	CY if error (source exhausted)
   439                              <1> 		;	NC if success,
   440                              <1> 		;	 al = byte read from source
   441                              <1> 		;	 ?src
   442                              <1> 		;	 ?src_remaining
   443                              <1> 		; CHG:	ds, si
   444                              <1> 		; STT:	bp -> depack stack frame
   445                              <1> 		;	UP
   446                              <1> read_byte:
   447 0000028E C576F8              <1> 	lds si, [bp + ?src]
   448 00000291 AC                  <1> 	lodsb
   449 00000292 1E                  <1> 	 push ds
   450 00000293 56                  <1> 	 push si
   451 00000294 E8E100              <1> 	call normalise_pointer
   452 00000297 8F46F8              <1> 	 pop word [bp + ?src]
   453 0000029A 8F46FA              <1> 	 pop word [bp + ?src + 2]
   454 0000029D 836EEC01            <1> 	sub word [bp + ?src_remaining], 1
   455 000002A1 835EEE00            <1> 	sbb word [bp + ?src_remaining + 2], 0
   456 000002A5 C3                  <1> 	retn
   457                              <1> 
   458                              <1> 
   459                              <1> 		; as for read_byte
   460                              <1> 		; OUT:	CY if error
   461                              <1> 		;	NC if success,
   462                              <1> 		;	 ?bit_buffer
   463                              <1> 		; CHG:	al, ds, si
   464                              <1> read_byte_to_bit_buffer:
   465 000002A6 E8E5FF              <1> 	call read_byte
   466 000002A9 8846FC              <1> 	mov byte [bp + ?bit_buffer], al
   467 000002AC C3                  <1> 	retn
   468                              <1> 
   469                              <1> 
   470                              <1> 		; INP:	CF = carry in
   471                              <1> 		;	?bit_buffer
   472                              <1> 		; OUT:	CF = carry out
   473                              <1> 		;	ZF = whether ?bit_buffer is now zero
   474                              <1> 		;	?bit_buffer
   475                              <1> 		; CHG:	-
   476                              <1> 		; STT:	bp -> depack stack frame
   477                              <1> bitbuffer_rotate:
   478                              <1> %if _P & 1
   479 000002AD D056FC              <1> 	rcl byte [bp + ?bit_buffer], 1
   480                              <1> %else
   481                              <1> 	rcr byte [bp + ?bit_buffer], 1
   482                              <1> %endif
   483 000002B0 FE4EFC              <1> 	dec byte [bp + ?bit_buffer]
   484 000002B3 FE46FC              <1> 	inc byte [bp + ?bit_buffer]	; this is to set ZF and preserve CF
   485 000002B6 C3                  <1> 	retn
   486                              <1> 
   487                              <1> 
   488                              <1> read_bits_1:
   489 000002B7 B90100              <1> 	mov cx, 1
   490                              <1> 
   491                              <1> 		; INP:	cl = cx = number of bits to read (0..15)
   492                              <1> 		; OUT:	CY if error (cx too high or source exhausted)
   493                              <1> 		;	NC if success,
   494                              <1> 		;	 ax = read data
   495                              <1> 		;	 cx = 0
   496                              <1> 		; CHG:	ds, si
   497                              <1> 		; STT:	bp -> depack stack frame
   498                              <1> 		;	UP
   499                              <1> read_bits:
   500                              <1> %if _P & 2
   501 000002BA 83F910              <1> 	cmp cx, 16		; CY if valid
   502                              <1> %else
   503                              <1> 	cmp cx, 17		; CY if valid
   504                              <1> %endif
   505 000002BD F5                  <1> 	cmc			; NC if valid
   506 000002BE 722B                <1> 	jc .ret			; if error --> (CY)
   507                              <1> %if _P & 2
   508 000002C0 88C8                <1> 	mov al, cl
   509 000002C2 88CC                <1> 	mov ah, cl
   510 000002C4 250708              <1> 	and ax, (8 << 8) | 7	; al = bit_count, ah = byte_copy
   511 000002C7 88C1                <1> 	mov cl, al		; cl = cx = bit_count
   512 000002C9 B000                <1> 	mov al, 0		; al = bits
   513                              <1> %else
   514                              <1> 	xor ax, ax		; ax = bits
   515                              <1> %endif
   516 000002CB E315                <1> 	jcxz .end
   517                              <1> .loop:
   518 000002CD F8                  <1> 	clc
   519 000002CE E8DCFF              <1> 	call bitbuffer_rotate
   520 000002D1 750B                <1> 	jnz .notzero
   521 000002D3 50                  <1> 	push ax
   522 000002D4 E8CFFF              <1> 	call read_byte_to_bit_buffer
   523 000002D7 58                  <1> 	pop ax
   524 000002D8 7211                <1> 	jc .ret			; if error --> (CY)
   525 000002DA F9                  <1> 	stc
   526 000002DB E8CFFF              <1> 	call bitbuffer_rotate
   527                              <1> .notzero:
   528                              <1> %if _P & 2
   529 000002DE D0D0                <1> 	rcl al, 1		; bits <<= 1; bits |= carry;
   530                              <1> %else
   531                              <1> 	rcl ax, 1
   532                              <1> %endif
   533 000002E0 E2EB                <1> 	loop .loop
   534                              <1> .end:
   535                              <1> %if _P & 2
   536 000002E2 84E4                <1> 	test ah, ah		; NC
   537 000002E4 7405                <1> 	jz .byte_copy_zero	; (NC)
   538 000002E6 88C4                <1> 	mov ah, al		; bits <<= 8;
   539 000002E8 E8A3FF              <1> 	call read_byte		; bits |= read_byte()
   540                              <1> 				; pass CF to caller
   541                              <1> .byte_copy_zero:		; ax = bits
   542                              <1> %endif
   543                              <1> .ret:
   544 000002EB C3                  <1> 	retn
   545                              <1> 
   546                              <1> 
   547                              <1> generate_table_16:
   548 000002EC B91000              <1> 	mov cx, 16
   549                              <1> 		; INP:	cx = amount of table entries
   550                              <1> 		;	bp + di -> start of table
   551                              <1> 		; OUT:	CY if error
   552                              <1> 		;	NC if success,
   553                              <1> 		;	 cx = 0
   554                              <1> 		; CHG:	ax, bx, di, ds, si
   555                              <1> 		; STT:	bp -> depack stack frame
   556                              <1> 		;	UP
   557                              <1> generate_table_cx:
   558 000002EF BB0100              <1> 	mov bx, 1
   559                              <1> .loop:
   560 000002F2 895B01              <1> 	mov word [bp + di + eteBase], bx
   561 000002F5 51                  <1> 	push cx
   562                              <1> %if _P & 2
   563 000002F6 B90300              <1> 	mov cx, 3
   564 000002F9 E8BEFF              <1> 	call read_bits
   565 000002FC 7221                <1> 	jc .ret_pop
   566 000002FE 8803                <1> 	mov byte [bp + di + eteBits], al
   567 00000300 B101                <1> 	mov cl, 1
   568 00000302 E8B5FF              <1> 	call read_bits
   569 00000305 7218                <1> 	jc .ret_pop
   570 00000307 D0E0                <1> 	shl al, 1
   571 00000309 D0E0                <1> 	shl al, 1
   572 0000030B D0E0                <1> 	shl al, 1
   573 0000030D 0803                <1> 	or byte [bp + di + eteBits], al
   574 0000030F B80100              <1> 	mov ax, 1
   575 00000312 8A0B                <1> 	mov cl, byte [bp + di + eteBits]
   576                              <1> %else
   577                              <1> 	mov cx, 4
   578                              <1> 	call read_bits
   579                              <1> 	jc .ret_pop
   580                              <1> 	mov byte [bp + di + eteBits], al
   581                              <1> 	mov cl, al
   582                              <1> 	mov ax, 1
   583                              <1> %endif
   584 00000314 D3E0                <1> 	shl ax, cl
   585 00000316 01C3                <1> 	add bx, ax
   586 00000318 59                  <1> 	pop cx
   587 00000319 83C703              <1> 	add di, exo_table_entry_size
   588 0000031C E2D4                <1> 	loop .loop
   589 0000031E A8                  <1> 	db __TEST_IMM8		; (skip pop, NC)
   590                              <1> .ret_pop:
   591 0000031F 59                  <1> 	pop cx
   592 00000320 C3                  <1> 	retn
   593                              <1> 
   594                              <1> 
   595                              <1> 		; INP:	ds:si -> data (normalised and in bounds)
   596                              <1> 		;	?dst (normalised), ?dst_remaining
   597                              <1> 		;	cx = number of bytes (entire range valid)
   598                              <1> 		; OUT:	CY if error (destination exhausted)
   599                              <1> 		;	NC if success,
   600                              <1> 		;	 ds:si -> behind copied source (normalised)
   601                              <1> 		;	 ?dst -> behind copied destination (normalised)
   602                              <1> 		;	 ?dst_remaining decremented
   603                              <1> 		;	 ax = cx = 0
   604                              <1> 		;	Instead of returning, this may jump to depack.end
   605                              <1> 		;	 if the destination segment grows up to the value
   606                              <1> 		;	 stored in the ?dst_max_segment variable. It is
   607                              <1> 		;	 assumed that this will use the stack frame to leave
   608                              <1> 		;	 the function, therefore discarding any of the stack
   609                              <1> 		;	 contents between the frame and the stack top.
   610                              <1> 		; CHG:	es, di
   611                              <1> 		; STT:	bp -> depack stack frame
   612                              <1> 		;	UP
   613                              <1> copy_data:
   614                              <1> d0	inc byte [bp + ?errordata + 1]
   615                              <1> 
   616 00000321 294EE8              <1> 	sub word [bp + ?dst_remaining], cx
   617 00000324 835EEA00            <1> 	sbb word [bp + ?dst_remaining + 2], 0
   618 00000328 7222                <1> 	jc .ret
   619 0000032A C47EF0              <1> 	les di, [bp + ?dst]
   620                              <1> 
   621 0000032D 31C0                <1> 	xor ax, ax			; initialise second step length
   622 0000032F 83F9F0              <1> 	cmp cx, 0FFF0h			; can copy in one step ?
   623 00000332 760C                <1> 	jbe @F				; yes -->
   624 00000334 88C8                <1> 	mov al, cl
   625 00000336 240F                <1> 	and al, 15			; second step length
   626 00000338 B1F0                <1> 	mov cl, 0F0h			; maximum first step = 0FFF0h
   627 0000033A F3A4                <1> 	rep movsb			; move first step of two steps
   628 0000033C E82A00              <1> 	call normalise_both_pointers	; normalise pointers after
   629 0000033F 91                  <1> 	xchg ax, cx			; cx = second step length
   630                              <1> @@:
   631 00000340 F3A4                <1> 	rep movsb			; move last step
   632 00000342 E82400              <1> 	call normalise_both_pointers	; normalise (again)
   633 00000345 897EF0              <1> 	mov word [bp + ?dst], di
   634 00000348 8C46F2              <1> 	mov word [bp + ?dst + 2], es	; store to ?dst
   635                              <1> %if _PAYLOAD_KERNEL_MAX_PARAS
   636                              <1> 	mov di, es			; ! this is the *segment*
   637                              <1> 	cmp di, word [bp + ?dst_max_segment]
   638                              <1> 	jae depack.end
   639                              <1> %endif
   640 0000034B F8                  <1> 	clc
   641                              <1> .ret:
   642 0000034C C3                  <1> 	retn
   992                                  %endif
   993                                  
   994                                  
   995                                  %if _X
   996                                  	%include "x.asm"
   997                                  %endif
   998                                  
   999                                  
  1000                                  %if _HEATSHRINK
  1001                                  	%include "heatshr.asm"
  1002                                  %endif
  1003                                  
  1004                                  
  1005                                  %if _LZD
  1006                                  	%include "lzd.asm"
  1007                                  %endif
  1008                                  
  1009                                  
  1010                                  %if _LZO
  1011                                  	%include "lzo.asm"
  1012                                  %endif
  1013                                  
  1014                                  
  1015                                  %if _LZSA2
  1016                                  	%include "lzsa2.asm"
  1017                                  %endif
  1018                                  
  1019                                  
  1020                                  %if _APL
  1021                                  	%include "apl.asm"
  1022                                  %endif
  1023                                  
  1024                                  
  1025                                  %if _BZP
  1026                                  	%include "bzp.asm"
  1027                                  %endif
  1028                                  
  1029                                  
  1030                                  %if _ALLOW_OVERLAPPING
  1031                                  		; INP:	?src, ?dst
  1032                                  		; OUT:	CY if error (?src < ?dst)
  1033                                  		;	NC if success
  1034                                  		; CHG:	ax, bx, cx, dx
  1035                                  check_pointers_not_overlapping:
  1036                                  %if CHECK_POINTERS_VARIABLE_DST
  1037 0000034D FF76F2                  	 push word [bp + ?dst + 2]
  1038 00000350 FF76F0                  	 push word [bp + ?dst]
  1039                                  %else
  1040                                  	 push es
  1041                                  	 push di
  1042                                  %endif
  1043 00000353 E87300                  	call pointer_to_linear
  1044                                  
  1045 00000356 91                      	xchg cx, ax
  1046 00000357 87DA                    	xchg bx, dx			; bx:cx = linear ?dst after write
  1047                                  
  1048                                  %if CHECK_POINTERS_VARIABLE_SRC
  1049 00000359 FF76FA                  	 push word [bp + ?src + 2]
  1050 0000035C FF76F8                  	 push word [bp + ?src]
  1051                                  %else
  1052                                  	 push ds
  1053                                  	 push si
  1054                                  %endif
  1055 0000035F E86700                  	call pointer_to_linear		; dx:ax = linear ?src before next read
  1056                                  
  1057 00000362 39DA                    	cmp dx, bx			; ?src >= ?dst ?
  1058 00000364 7502                    	jne @F
  1059 00000366 39C8                    	cmp ax, cx
  1060                                  @@:
  1061                                  					; (CY) if error (src < dst)
  1062                                  					; (NC) if no error
  1063 00000368 C3                      	retn
  1064                                  %endif
  1065                                  
  1066                                  	; This leaves the lframe context created within the
  1067                                  	;  specific depacker's file. The above function
  1068                                  	;  check_pointers_not_overlapping uses the frame.
  1069                                  	lleave ctx
  1070                                  
  1071                                  
  1072                                  		; INP:	ds:si = pointer
  1073                                  		;	es:di = pointer
  1074                                  		; OUT:	ds:si normalised
  1075                                  		;	es:di normalised
  1076                                  normalise_both_pointers:
  1077 00000369 06                      	 push es
  1078 0000036A 57                      	 push di
  1079 0000036B E80A00                  	call normalise_pointer
  1080 0000036E 5F                      	 pop di
  1081 0000036F 07                      	 pop es
  1082                                  
  1083                                  normalise_dssi_pointer:
  1084 00000370 1E                      	 push ds
  1085 00000371 56                      	 push si
  1086 00000372 E80300                  	call normalise_pointer
  1087 00000375 5E                      	 pop si
  1088 00000376 1F                      	 pop ds
  1089 00000377 C3                      	retn
  1090                                  
  1091                                  
  1092                                  		; INP:	word [ss:sp + 2] = segment
  1093                                  		;	word [ss:sp] = offset
  1094                                  		;
  1095                                  		; Note:	Does not work correctly with pointers that point to
  1096                                  		;	 a HMA location. Do not use then!
  1097                                  normalise_pointer:
  1098                                  %if NEED_NORMALISE_POINTER_WITH_DISPLACEMENT
  1099                                  	lframe near
  1100                                  	lpar word,	segment
  1101                                  	lpar word,	offset
  1102                                  	lpar_return
  1103 00000378 5589E5                  	lenter
  1104                                  
  1105 0000037B 837E040F                	cmp word [bp + ?offset], 15
  1106 0000037F 7617                    	jbe .ret
  1107                                  
  1108 00000381 53                      	push bx
  1109 00000382 51                      	push cx
  1110                                  
  1111 00000383 31DB                    	xor bx, bx
  1112 00000385 31C9                    	xor cx, cx
  1113 00000387 FF7606                  	 push word [bp + ?segment]
  1114 0000038A FF7604                  	 push word [bp + ?offset]
  1115 0000038D E80A00                  	call normalise_pointer_with_displacement_bxcx
  1116 00000390 8F4604                  	 pop word [bp + ?offset]
  1117 00000393 8F4606                  	 pop word [bp + ?segment]
  1118                                  
  1119 00000396 59                      	pop cx
  1120 00000397 5B                      	pop bx
  1121                                  .ret:
  1122 00000398 5D                      	lleave
  1123 00000399 C3                      	lret
  1124                                  
  1125                                  
  1126                                  		; INP:	word [ss:sp + 2] = segment
  1127                                  		;	word [ss:sp] = offset
  1128                                  		;	bx:cx = add/sub displacement
  1129                                  		; OUT:	CY if the displacement carries
  1130                                  		;	NC if not
  1131                                  normalise_pointer_with_displacement_bxcx:
  1132                                  %endif
  1133                                  	lframe near
  1134                                  	lpar word,	segment
  1135                                  	lpar word,	offset
  1136                                  	lpar_return
  1137 0000039A 5589E5                  	lenter
  1138                                  
  1139                                  %ifn NEED_NORMALISE_POINTER_WITH_DISPLACEMENT
  1140                                  	cmp word [bp + ?offset], 15
  1141                                  	jbe .ret
  1142                                  %endif
  1143                                  
  1144 0000039D 50                      	push ax
  1145 0000039E 51                      	push cx
  1146 0000039F 52                      	push dx
  1147                                  
  1148 000003A0 FF7606                  	 push word [bp + ?segment]
  1149 000003A3 FF7604                  	 push word [bp + ?offset]
  1150 000003A6 E82000                  	call pointer_to_linear
  1151                                  
  1152                                  %if NEED_NORMALISE_POINTER_WITH_DISPLACEMENT
  1153                                  	; push bx
  1154                                  	; 				; sign-extend cx into bx:cx
  1155                                  	; cmp cx, 8000h			; CY if < 8000h (NC if negative)
  1156                                  	; cmc				; NC if positive
  1157                                  	; sbb bx, bx			; 0 if was NC, -1 if was CY
  1158                                  
  1159 000003A9 01C1                    	add cx, ax
  1160 000003AB 11DA                    	adc dx, bx			; dx:cx = dx:ax + bx:cx
  1161                                  	; pop bx
  1162 000003AD 9F                      	lahf				; ah = flags
  1163                                  %else
  1164                                  	xchg ax, cx
  1165                                  %endif
  1166                                  
  1167                                  %if 0
  1168                                  		; Adds in HMA support for this function. Not currently used.
  1169                                  	cmp dx, 10h			; dx:ax >= 10_0000h ?
  1170                                  	jb @F				; no, linear-to-pointer normally -->
  1171                                  	; ja .error
  1172                                  
  1173                                  	add cx, 10h
  1174                                  	; jc .error
  1175                                  	mov word [bp + ?offset], cx
  1176                                  	or word [bp + ?segment], -1
  1177                                  	jmp .return
  1178                                  @@:
  1179                                  %endif
  1180                                  
  1181 000003AE 53                      	push bx
  1182 000003AF 89CB                    	mov bx, cx
  1183 000003B1 83E10F                  	and cx, 15
  1184 000003B4 894E04                  	mov word [bp + ?offset], cx
  1185                                  
  1186 000003B7 B104                    	mov cl, 4
  1187                                  @@:
  1188 000003B9 D1EA                    	shr dx, 1
  1189 000003BB D1DB                    	rcr bx, 1
  1190 000003BD E2FA                    	loop @B
  1191                                  
  1192 000003BF 895E06                  	mov word [bp + ?segment], bx
  1193 000003C2 5B                      	pop bx
  1194                                  
  1195                                  	; test dx, dx
  1196                                  	; jnz .error
  1197                                  
  1198                                  .return:
  1199                                  
  1200                                  %if NEED_NORMALISE_POINTER_WITH_DISPLACEMENT
  1201 000003C3 9E                      	sahf				; restore flags from ah
  1202                                  %endif
  1203 000003C4 5A                      	pop dx
  1204 000003C5 59                      	pop cx
  1205 000003C6 58                      	pop ax
  1206                                  %ifn NEED_NORMALISE_POINTER_WITH_DISPLACEMENT
  1207                                  .ret:
  1208                                  %endif
  1209 000003C7 5D                      	lleave
  1210 000003C8 C3                      	lret
  1211                                  
  1212                                  
  1213                                  		; INP:	word [ss:sp + 2] = segment
  1214                                  		;	word [ss:sp] = offset
  1215                                  		; OUT:	dx:ax = linear address
  1216                                  pointer_to_linear:
  1217                                  	lframe near
  1218                                  	lpar word,	segment
  1219                                  	lpar word,	offset
  1220 000003C9 5589E5                  	lenter
  1221                                  
  1222 000003CC 8B4606                  	mov ax, word [bp + ?segment]
  1223 000003CF 31D2                    	xor dx, dx
  1224 000003D1 51                      	push cx
  1225 000003D2 B90400                  	mov cx, 4
  1226                                  @@:
  1227 000003D5 D1E0                    	shl ax, 1
  1228 000003D7 D1D2                    	rcl dx, 1
  1229 000003D9 E2FA                    	loop @B
  1230                                  
  1231 000003DB 034604                  	add ax, word [bp + ?offset]
  1232 000003DE 11CA                    	adc dx, cx			; cx = 0 here
  1233 000003E0 59                      	pop cx
  1234                                  
  1235 000003E1 5D                      	lleave
  1236 000003E2 C20400                  	lret
  1237                                  
  1238                                  
  1239 000003E5 90<rep Bh>              	align 16
  1240                                  init1_end:
  1241                                  
  1242                                  
  1243                                  	section INIT0
  1244                                  %if _TEST_PROGRAM
  1245                                  init0_msg:
  1246 0000025F 4572726F723A204E6F-     .error_stderr:	db "Error: Not enough memory allocated.",13,10
  1246 00000268 7420656E6F75676820-
  1246 00000271 6D656D6F727920616C-
  1246 0000027A 6C6F63617465642E0D-
  1246 00000283 0A                 
  1247                                  .error_stderr.length: equ $ - .error_stderr
  1248 00000284 3132343235              .error_stdout:	_autodigits paras(_TEST_PROGRAM_DECOMPRESSED_SIZE 				+ (payload_end - payload) 				+ (init1_end - init1_start) 				+ ADDITIONAL_MEMORY 				)
  1253 00000289 0D0A                    		db 13,10
  1254                                  .error_stdout.length: equ $ - .error_stdout
  1255                                  
  1256 0000028B 90<rep 175h>            	align 1024
  1257                                  %if ($ - $$) != 1024
  1258                                   %error Wrong INIT0 size
  1259                                  %endif
  1260                                  %endif
  1261                                  
  1262                                  	align 16
  1263                                  init0_end:
  1264                                  
  1265                                  
  1266                                  %assign num (init1_end - init1_start) + (init0_end - init0_start)
  1267                                  %if _BRIEFLZ
  1268                                  %define which iniblz
  1269                                  %elif _LZ4
  1270                                  %define which inilz4
  1271                                  %elif _SNAPPY
  1272                                  %define which inisz
  1273                                  %elif _EXODECR
  1274                                  %define which iniexo
  1275                                  %elif _X
  1276                                  %define which inix
  1277                                  %elif _HEATSHRINK
  1278                                  %define which inihs
  1279                                  %elif _LZD
  1280                                  %define which inilz
  1281                                  %elif _LZO
  1282                                  %define which inilzo
  1283                                  %elif _LZSA2
  1284                                  %define which inilzsa2
  1285                                  %elif _APL
  1286                                  %define which iniapl
  1287                                  %elif _BZP
  1288                                  %define which inibzp
  1289                                  %endif
  1290                                  %warning which: num bytes used for depacker
  1290          ******************       warning: iniexo: 2032 bytes used for depacker [-w+user]
  1291                                  
  1292                                  
  1293                                  %if _TEST_PROGRAM
  1294                                  	section INIT2 align=16 follows=INIT1 vstart=0
  1295                                  init2_start:
  1296                                  		; si => after PSP
  1297                                  		; cs => INIT2
  1298                                  		; psp, free, payload, init1, init2, payload space, stack
  1299                                  		;
  1300                                  		; The correct allocation for the test program
  1301                                  		;  is image size (init0, payload, init1, init2)
  1302                                  		;  minus init0 plus compressed payload size
  1303                                  		;  plus decompressed size plus stack. For
  1304                                  		;  simplicity, init0 subtraction may be skipped.
  1305                                  
  1306                                  		; ss:sp -> word amount repetitions, word ax
  1307                                  		; bx = 1 if A test, 8001h if B test
  1308 00000000 53                      	push bx
  1309                                  
  1310                                  	lframe 0
  1311                                  	lpar word,	repetitions
  1312                                  	lpar word,	whichtest
  1313 00000001 5589E5                  	lenter
  1314                                  
  1315 00000004 8B5604                  	mov dx, word [bp + ?repetitions]
  1316 00000007 83FAFF                  	cmp dx, -1
  1317 0000000A 7509                    	jne @F
  1318                                  
  1319                                  .cmdline_error:
  1320                                  %if _DEBUG0
  1321                                  	mov bx, -1
  1322                                  %endif
  1323 0000000C BA[9F02]                	mov dx, init2_msg.cmdline_error
  1324 0000000F B92400                  	mov cx, init2_msg.cmdline_error.length
  1325 00000012 E95B01                  	jmp init2_error
  1326                                  
  1327                                  
  1328                                  @@:
  1329 00000015 F6460380                	testopt [bp + ?whichtest], 8000h
  1330 00000019 7406                    	jz .a
  1331                                  .b:
  1332 0000001B 85D2                    	test dx, dx
  1333 0000001D 74ED                    	jz .cmdline_error
  1334 0000001F EB04                    	jmp @F
  1335                                  
  1336                                  .a:
  1337 00000021 85D2                    	test dx, dx
  1338 00000023 75E7                    	jnz .cmdline_error
  1339                                  @@:
  1340                                  
  1341 00000025 8CCA                    	mov dx, cs
  1342 00000027 81C2D31D                	add dx, (init2_end - init2_start) >> 4
  1343                                  				; => payload saving area
  1344 0000002B 8CC8                    	mov ax, cs
  1345 0000002D 2DED12                  	sub ax, ( (init1_end - init1_start) 		+ (payload_end - payload) 		) >> 4		; => payload source for first run
  1348 00000030 B9AE12                  	mov cx, (payload_end - payload) >> 4
  1349 00000033 E89402                  	call init2_movp		; copy payload to payload saving area
  1350                                  		; We save away the payload here because a failure
  1351                                  		;  to decompress generally overwrites part of that
  1352                                  		;  payload which was used as source.
  1353                                  
  1354 00000036 89C2                    	mov dx, ax		; dx => payload source to use
  1355 00000038 8CC8                    	mov ax, cs
  1356 0000003A 83E83F                  	sub ax, (init1_end - init1_start) >> 4
  1357                                  				; ax => INIT1
  1358 0000003D BB0100                  	mov bx, 1		; say we're in EXE mode
  1359 00000040 52                      	push dx
  1360 00000041 50                      	push ax
  1361 00000042 56                      	push si			; si => target
  1362 00000043 0E                      	 push cs
  1363 00000044 E8EA00                  	 call .transfer		; call decompression
  1364 00000047 5E                      	pop si
  1365 00000048 58                      	pop ax
  1366 00000049 5A                      	pop dx
  1367                                  		; Returns here after decompression.
  1368                                  		; CY if error.
  1369 0000004A 7309                    	jnc @F
  1370                                  
  1371 0000004C BA[F001]                	mov dx, init2_msg.initial_error
  1372 0000004F B93C00                  	mov cx, init2_msg.initial_error.length
  1373 00000052 E91B01                  	jmp init2_error
  1374                                  
  1375                                  @@:
  1376                                  	numdef INCLUDE_UNCOMPRESSED
  1377                                  	numdef WRITE_WRONG_FILE
  1378                                  %if _INCLUDE_UNCOMPRESSED
  1379                                  payload_uncompressed_size equ payload_uncompressed.end - payload_uncompressed
  1380                                  
  1381 00000055 E8DF00                  	call checkdecompressed
  1382 00000058 7409                    	je @F
  1383                                  
  1384                                  %if _WRITE_WRONG_FILE
  1385                                  	call writefiles
  1386                                  %endif
  1387                                  
  1388                                  %if _DEBUG0
  1389                                  	mov bx, -1
  1390                                  %endif
  1391 0000005A BA[2C02]                	mov dx, init2_msg.initial_error_2
  1392 0000005D B93C00                  	mov cx, init2_msg.initial_error_2.length
  1393 00000060 E90D01                  	jmp init2_error
  1394                                  
  1395                                  @@:
  1396                                  %endif
  1397                                  
  1398                                  	lvar word,	upperbound
  1399 00000063 52                      	 push dx
  1400                                  	lvar word,	lowerbound
  1401 00000064 56                      	 push si
  1402                                  	lvar word,	current_init1
  1403 00000065 50                      	 push ax
  1404                                  
  1405                                  %if _TEST_PROGRESS
  1406 00000066 BA[E501]                	mov dx, init2_msg.progress.1
  1407 00000069 B90700                  	mov cx, init2_msg.progress.1.length
  1408                                  .loop:
  1409 0000006C 0E                      	push cs
  1410 0000006D 1F                      	pop ds
  1411 0000006E BB0200                  	mov bx, 2
  1412 00000071 B440                    	mov ah, 40h
  1413 00000073 CD21                    	int 21h
  1414                                  %else
  1415                                  .loop:
  1416                                  %endif
  1417                                  
  1418 00000075 8B56FE                  	mov dx, [bp + ?upperbound]
  1419                                  
  1420 00000078 F6460380                	testopt [bp + ?whichtest], 8000h
  1421 0000007C 7419                    	jz @F
  1422                                  
  1423 0000007E FF4E04                  	dec word [bp + ?repetitions]
  1424 00000081 751E                    	jnz .test_b_skip_bound
  1425                                  
  1426                                  %if _TEST_PROGRESS
  1427 00000083 0E                      	push cs
  1428 00000084 1F                      	pop ds
  1429 00000085 BA[EE01]                	mov dx, init2_msg.progress.linebreak
  1430 00000088 B90200                  	mov cx, init2_msg.progress.linebreak.length
  1431 0000008B BB0200                  	mov bx, 2
  1432 0000008E B440                    	mov ah, 40h
  1433 00000090 CD21                    	int 21h
  1434                                  %endif
  1435 00000092 B8004C                  	mov ax, 4C00h
  1436 00000095 CD21                    	int 21h
  1437                                  
  1438                                  
  1439                                  @@:
  1440 00000097 2B56FC                  	sub dx, [bp + ?lowerbound]
  1441 0000009A 746C                    	jz .found
  1442 0000009C D1EA                    	shr dx, 1
  1443                                  		; Rounding down, so that we never retry upper bound.
  1444                                  		;  The upper bound is known to be working.
  1445 0000009E 0356FC                  	add dx, [bp + ?lowerbound]
  1446                                  
  1447                                  .test_b_skip_bound:
  1448 000000A1 52                      	push dx
  1449 000000A2 81C2AE12                	add dx, (payload_end - payload) >> 4
  1450 000000A6 8B46FA                  	mov ax, [bp + ?current_init1]
  1451 000000A9 B93F00                  	mov cx, (init1_end - init1_start) >> 4
  1452 000000AC E81B02                  	call init2_movp
  1453 000000AF 8956FA                  	mov [bp + ?current_init1], dx
  1454 000000B2 5A                      	pop dx
  1455                                  
  1456 000000B3 8CC8                    	mov ax, cs
  1457 000000B5 05D31D                  	add ax, (init2_end - init2_start) >> 4
  1458                                  				; => payload in saving area
  1459 000000B8 B9AE12                  	mov cx, (payload_end - payload) >> 4
  1460 000000BB E80C02                  	call init2_movp		; copy payload from payload saving area
  1461                                  
  1462                                  		; dx => source
  1463 000000BE 8B46FA                  	mov ax, [bp + ?current_init1]
  1464 000000C1 BB0100                  	mov bx, 1
  1465 000000C4 52                      	push dx
  1466 000000C5 56                      	push si
  1467 000000C6 0E                      	 push cs
  1468 000000C7 E86700                  	 call .transfer
  1469 000000CA 5E                      	pop si
  1470 000000CB 5A                      	pop dx
  1471                                  		; Returns here after decompression.
  1472                                  		; CY if error.
  1473 000000CC 7312                    	jnc @F
  1474                                  
  1475 000000CE F6460380                	testopt [bp + ?whichtest], 8000h
  1476 000000D2 7511                    	jnz .test_b_fail
  1477                                  
  1478                                  		; error: this attempt is one below the new lower bound
  1479 000000D4 42                      	inc dx
  1480 000000D5 8956FC                  	mov word [bp + ?lowerbound], dx
  1481                                  
  1482                                  %if _TEST_PROGRESS
  1483 000000D8 BA[EC01]                	mov dx, init2_msg.progress.fail
  1484 000000DB B90100                  	mov cx, init2_msg.progress.fail.length
  1485                                  %endif
  1486 000000DE EB8C                    	jmp .loop
  1487                                  
  1488                                  @@:
  1489                                  %if _INCLUDE_UNCOMPRESSED
  1490 000000E0 E85400                  	call checkdecompressed
  1491 000000E3 7417                    	je @F
  1492                                  
  1493                                  %if _WRITE_WRONG_FILE
  1494                                  	call writefiles
  1495                                  %endif
  1496                                  
  1497                                  .test_b_fail:
  1498                                  %if _TEST_PROGRESS
  1499 000000E5 0E                      	push cs
  1500 000000E6 1F                      	pop ds
  1501 000000E7 BA[EE01]                	mov dx, init2_msg.progress.linebreak
  1502 000000EA B90200                  	mov cx, init2_msg.progress.linebreak.length
  1503 000000ED BB0200                  	mov bx, 2
  1504 000000F0 B440                    	mov ah, 40h
  1505 000000F2 CD21                    	int 21h
  1506                                  %endif
  1507                                  %if _DEBUG0
  1508                                  	mov bx, -2
  1509                                  %endif
  1510 000000F4 BA[6802]                	mov dx, init2_msg.subsequent_error_2
  1511 000000F7 B93700                  	mov cx, init2_msg.subsequent_error_2.length
  1512 000000FA EB74                    	jmp init2_error
  1513                                  
  1514                                  @@:
  1515                                  %endif
  1516                                  		; success: this attempt is the new upper bound
  1517 000000FC 8956FE                  	mov word [bp + ?upperbound], dx
  1518                                  %if _TEST_PROGRESS
  1519 000000FF BA[ED01]                	mov dx, init2_msg.progress.success
  1520 00000102 B90100                  	mov cx, init2_msg.progress.success.length
  1521                                  %endif
  1522 00000105 E964FF                  	jmp .loop
  1523                                  
  1524                                  .found:
  1525                                  %if _TEST_PROGRESS
  1526 00000108 0E                      	push cs
  1527 00000109 1F                      	pop ds
  1528 0000010A BA[EE01]                	mov dx, init2_msg.progress.linebreak
  1529 0000010D B90200                  	mov cx, init2_msg.progress.linebreak.length
  1530 00000110 BB0200                  	mov bx, 2
  1531 00000113 B440                    	mov ah, 40h
  1532 00000115 CD21                    	int 21h
  1533                                  %endif
  1534 00000117 8B46FE                  	mov ax, word [bp + ?upperbound]
  1535 0000011A 29F0                    	sub ax, si		; = how many paragraphs in buffer before source
  1536 0000011C 05ED12                  	add ax, paras( (init1_end - init1_start) 			+ (payload_end - payload) )
  1538                                  				; = how many paragraphs needed for process
  1539 0000011F E87A00                  	call init2_disp_ax_dec
  1540 00000122 B00D                    	mov al, 13
  1541 00000124 E86A00                  	call init2_disp_al
  1542 00000127 B00A                    	mov al, 10
  1543 00000129 E86500                  	call init2_disp_al
  1544 0000012C B8004C                  	mov ax, 4C00h
  1545 0000012F CD21                    	int 21h
  1546                                  
  1547                                  
  1548                                  .transfer:
  1549 00000131 31FF                    	xor di, di
  1550 00000133 57                      	push di			; dummy ax value on stack
  1551 00000134 50                      	push ax			; INIT1 segment
  1552 00000135 57                      	push di			; zero = init1_start
  1553 00000136 CB                      	retf
  1554                                  
  1555                                  
  1556                                  
  1557                                  %if _INCLUDE_UNCOMPRESSED
  1558                                  
  1559                                  
  1560                                  %if _WRITE_WRONG_FILE
  1561                                  writefiles:
  1562                                  	push cs
  1563                                  	pop ds
  1564                                  	mov dx, init2_msg.wrong_file_name
  1565                                  	xor cx, cx
  1566                                  	mov ah, 3Ch
  1567                                  	int 21h
  1568                                  	jc .notfile
  1569                                  
  1570                                  	mov bx, ax
  1571                                  	mov cx, payload_uncompressed_size >> 4
  1572                                  	xor dx, dx
  1573                                  .loopfile:
  1574                                  	mov ds, si
  1575                                  	mov ah, 40h
  1576                                  	push cx
  1577                                  	mov cx, 16
  1578                                  	int 21h
  1579                                  	pop cx
  1580                                  	inc si
  1581                                  	loop .loopfile
  1582                                  
  1583                                  	mov ds, si
  1584                                  	mov cx, payload_uncompressed_size & 15
  1585                                  	mov ah, 40h
  1586                                  	int 21h
  1587                                  
  1588                                  	mov ah, 3Eh
  1589                                  	int 21h
  1590                                  
  1591                                  .notfile:
  1592                                  
  1593                                  	push cs
  1594                                  	pop ds
  1595                                  	mov dx, init2_msg.wrong_file_name2
  1596                                  	xor cx, cx
  1597                                  	mov ah, 3Ch
  1598                                  	int 21h
  1599                                  	jc .notfile2
  1600                                  
  1601                                  	mov bx, ax
  1602                                  	mov cx, payload_uncompressed_size >> 4
  1603                                  	mov si, cs
  1604                                  	add si, (payload_uncompressed - init2_start) >> 4
  1605                                  	xor dx, dx
  1606                                  .loopfile2:
  1607                                  	mov ds, si
  1608                                  	mov ah, 40h
  1609                                  	push cx
  1610                                  	mov cx, 16
  1611                                  	int 21h
  1612                                  	pop cx
  1613                                  	inc si
  1614                                  	loop .loopfile2
  1615                                  
  1616                                  	mov ds, si
  1617                                  	mov cx, payload_uncompressed_size & 15
  1618                                  	mov ah, 40h
  1619                                  	int 21h
  1620                                  
  1621                                  	mov ah, 3Eh
  1622                                  	int 21h
  1623                                  
  1624                                  .notfile2:
  1625                                  	retn
  1626                                  %endif
  1627                                  
  1628                                  		; INP:	si => decompressed image
  1629                                  		; OUT:	ZR if matching
  1630                                  		;	NZ if mismatching
  1631                                  		; CHG:	es, ds, di, bx, cx
  1632                                  		; STT:	UP
  1633                                  checkdecompressed:
  1634 00000137 50                      	push ax
  1635 00000138 52                      	push dx
  1636 00000139 56                      	push si
  1637                                  %if _PAYLOAD_KERNEL_MAX_PARAS
  1638                                  	mov cx, _PAYLOAD_KERNEL_MAX_PARAS
  1639                                  	mov bx, 0
  1640                                  %else
  1641 0000013A B99C1D                  	mov cx, payload_uncompressed_size >> 4
  1642 0000013D BB0000                  	mov bx, payload_uncompressed_size & 15
  1643                                  %endif
  1644 00000140 8CCF                    	mov di, cs
  1645 00000142 83C736                  	add di, (payload_uncompressed - init2_start) >> 4
  1646 00000145 E319                    	jcxz .end
  1647                                  .loop:
  1648 00000147 51                      	push cx
  1649 00000148 B90800                  	mov cx, 8
  1650 0000014B 8EDE                    	mov ds, si
  1651 0000014D 8EC7                    	mov es, di
  1652 0000014F 46                      	inc si
  1653 00000150 47                      	inc di
  1654 00000151 56                      	push si
  1655 00000152 57                      	push di
  1656 00000153 31F6                    	xor si, si
  1657 00000155 31FF                    	xor di, di
  1658 00000157 F3A7                    	repe cmpsw
  1659 00000159 5F                      	pop di
  1660 0000015A 5E                      	pop si
  1661 0000015B 59                      	pop cx
  1662 0000015C 750E                    	jne .ret
  1663 0000015E E2E7                    	loop .loop
  1664                                  .end:
  1665 00000160 8EDE                    	mov ds, si
  1666 00000162 8EC7                    	mov es, di
  1667 00000164 31F6                    	xor si, si
  1668 00000166 31FF                    	xor di, di		; (ZR)
  1669 00000168 89D9                    	mov cx, bx
  1670 0000016A F3A6                    	repe cmpsb
  1671                                  .ret:
  1672 0000016C 5E                      	pop si
  1673 0000016D 5A                      	pop dx
  1674 0000016E 58                      	pop ax
  1675 0000016F C3                      	retn
  1676                                  %endif
  1677                                  
  1678                                  
  1679                                  init2_error:
  1680                                  %if _DEBUG0
  1681                                  	push bx
  1682                                  %endif
  1683 00000170 0E                      	push cs
  1684 00000171 1F                      	pop ds
  1685 00000172 BB0200                  	mov bx, 2
  1686 00000175 B440                    	mov ah, 40h
  1687 00000177 CD21                    	int 21h
  1688                                  
  1689                                  %if _DEBUG0
  1690                                  	mov dx, init2_msg.rc
  1691                                  	mov cx, init2_msg.rc.length
  1692                                  	mov bx, 2
  1693                                  	mov ah, 40h
  1694                                  	int 21h
  1695                                  	pop ax
  1696                                  	call init2_error_disp_ax_hex
  1697                                  	mov dx, init2_msg.linebreak
  1698                                  	mov cx, init2_msg.linebreak.length
  1699                                  	mov bx, 2
  1700                                  	mov ah, 40h
  1701                                  	int 21h
  1702                                  %endif
  1703                                  
  1704 00000179 F6460380                	testopt [bp + ?whichtest], 8000h
  1705 0000017D 750D                    	jnz @F
  1706                                  
  1707 0000017F BA[C302]                	mov dx, init2_msg.error_stdout
  1708 00000182 B90700                  	mov cx, init2_msg.error_stdout.length
  1709 00000185 BB0100                  	mov bx, 1
  1710 00000188 B440                    	mov ah, 40h
  1711 0000018A CD21                    	int 21h
  1712                                  @@:
  1713 0000018C B8FF4C                  	mov ax, 4CFFh
  1714 0000018F CD21                    	int 21h
  1715                                  
  1716                                  	lleave ctx
  1717                                  
  1718                                  
  1719                                  %if _DEBUG0
  1720                                  init2_error_disp_ax_hex:	; ax
  1721                                  		xchg al,ah
  1722                                  		call init2_error_disp_al_hex	; display former ah
  1723                                  		xchg al,ah			;  and fall trough for al
  1724                                  init2_error_disp_al_hex:	; al
  1725                                  		push cx
  1726                                  		mov cl,4
  1727                                  		ror al,cl
  1728                                  		call init2_error_disp_al_lownibble_hex
  1729                                  						; display former high-nibble
  1730                                  		rol al,cl
  1731                                  		pop cx
  1732                                  						;  and fall trough for low-nibble
  1733                                  init2_error_disp_al_lownibble_hex:
  1734                                  		push ax			 ; save ax for call return
  1735                                  		and al,00001111b		; high nibble must be zero
  1736                                  		add al,'0'			; if number is 0-9, now it's the correct character
  1737                                  		cmp al,'9'
  1738                                  		jna .decimalnum		 ; if we get decimal number with this, ok -->
  1739                                  		add al,7			;  otherwise, add 7 and we are inside our alphabet
  1740                                   .decimalnum:
  1741                                  		call init2_error_disp_al
  1742                                  		pop ax
  1743                                  		retn
  1744                                  
  1745                                  
  1746                                  init2_error_disp_al:
  1747                                  	push dx
  1748                                  	push cx
  1749                                  	push bx
  1750                                  	push ax
  1751                                  	mov dx, sp
  1752                                  	push ds
  1753                                  	 push ss
  1754                                  	 pop ds
  1755                                  	mov cx, 1
  1756                                  	mov bx, 2
  1757                                  	mov ah, 40h
  1758                                  	int 21h
  1759                                  	pop ds
  1760                                  	pop ax
  1761                                  	pop bx
  1762                                  	pop cx
  1763                                  	pop dx
  1764                                  	retn
  1765                                  %endif
  1766                                  
  1767                                  
  1768                                  init2_disp_al:
  1769 00000191 52                      	push dx
  1770 00000192 50                      	push ax
  1771 00000193 88C2                    	mov dl, al
  1772 00000195 B402                    	mov ah, 2
  1773 00000197 CD21                    	int 21h
  1774 00000199 58                      	pop ax
  1775 0000019A 5A                      	pop dx
  1776 0000019B C3                      	retn
  1777                                  
  1778                                  
  1779                                  		; Display number in ax decimal
  1780                                  		;
  1781                                  		; INP:	ax = number
  1782                                  		; OUT:	displayed using Int21.02
  1783                                  		; CHG:	none
  1784                                  init2_disp_ax_dec:			; ax (no leading zeros)
  1785 0000019C 53                      		push bx
  1786 0000019D 31DB                    		xor bx, bx
  1787                                  .pushax:
  1788 0000019F 52                      		push dx
  1789 000001A0 50                      		push ax
  1790 000001A1 08DB                    		or bl, bl
  1791 000001A3 7405                    		jz .nobl
  1792 000001A5 80EB05                  		sub bl, 5
  1793 000001A8 F6DB                    		neg bl
  1794                                  .nobl:
  1795 000001AA 51                      		push cx
  1796 000001AB B91027                  		mov cx, 10000
  1797 000001AE E81B00                  		call .divide_out
  1798 000001B1 B9E803                  		mov cx, 1000
  1799 000001B4 E81500                  		call .divide_out
  1800 000001B7 B96400                  		mov cx, 100
  1801 000001BA E80F00                  		call .divide_out
  1802 000001BD B10A                    		mov cl, 10
  1803 000001BF E80A00                  		call .divide_out
  1804                                  							; (Divisor 1 is useless)
  1805 000001C2 0430                    		add al, '0'
  1806 000001C4 E8CAFF                  		call init2_disp_al
  1807 000001C7 59                      		pop cx
  1808 000001C8 58                      		pop ax
  1809 000001C9 5A                      		pop dx
  1810 000001CA 5B                      		pop bx					; Caller's register
  1811 000001CB C3                      		retn
  1812                                  
  1813                                  
  1814                                  		; INP:	ax = number
  1815                                  		;	cx = divisor
  1816                                  		; OUT:	ax = remainder of operation
  1817                                  		;	result displayed
  1818                                  .divide_out:
  1819 000001CC 52                      		push dx
  1820 000001CD 31D2                    		xor dx, dx
  1821 000001CF F7F1                    		div cx				; 0:ax / cx
  1822 000001D1 52                      		push dx				; remainder
  1823 000001D2 FECB                    		dec bl
  1824 000001D4 7503                    		jnz .nobl2
  1825 000001D6 80CF01                  		or bh, 1
  1826                                  .nobl2:
  1827 000001D9 08C7                    		or bh, al
  1828 000001DB 7405                    		jz .leadingzero
  1829 000001DD 0430                    		add al, '0'
  1830 000001DF E8AFFF                  		call init2_disp_al		; display result
  1831                                   .leadingzero:
  1832 000001E2 58                      		pop ax				; remainder
  1833 000001E3 5A                      		pop dx
  1834 000001E4 C3                      		retn
  1835                                  
  1836                                  
  1837                                  init2_msg:
  1838                                  %if _TEST_PROGRESS
  1839 000001E5 496E666F3A2031          .progress.1:		db "Info: 1"
  1840                                  .progress.1.length: equ $ - .progress.1
  1841 000001EC 46                      .progress.fail:		db "F"
  1842                                  .progress.fail.length: equ $ - .progress.fail
  1843 000001ED 53                      .progress.success:	db "S"
  1844                                  .progress.success.length: equ $ - .progress.success
  1845 000001EE 0D0A                    .progress.linebreak:	db 13,10
  1846                                  .progress.linebreak.length: equ $ - .progress.linebreak
  1847                                  %endif
  1848                                  %if _WRITE_WRONG_FILE
  1849                                  .wrong_file_name:	asciz "WRONG.BIN"
  1850                                  .wrong_file_name2:	asciz "WRONG2.BIN"
  1851                                  %endif
  1852 000001F0 4572726F723A205465-     .initial_error:	db "Error: Test program failed to decompress with full buffer."
  1852 000001F9 73742070726F677261-
  1852 00000202 6D206661696C656420-
  1852 0000020B 746F206465636F6D70-
  1852 00000214 726573732077697468-
  1852 0000021D 2066756C6C20627566-
  1852 00000226 6665722E           
  1853 0000022A 0D0A                    .linebreak:	db 13,10
  1854                                  .initial_error.length: equ $ - .initial_error
  1855                                  .linebreak.length: equ $ - .linebreak
  1856                                  %if _DEBUG0
  1857                                  .rc:	db "Error: Failure code="
  1858                                  .rc.length: equ $ - .rc
  1859                                  %endif
  1860                                  %if _INCLUDE_UNCOMPRESSED
  1861 0000022C 4572726F723A205465-     .initial_error_2:	db "Error: Test program decompressed wrongly with full buffer.",13,10
  1861 00000235 73742070726F677261-
  1861 0000023E 6D206465636F6D7072-
  1861 00000247 65737365642077726F-
  1861 00000250 6E676C792077697468-
  1861 00000259 2066756C6C20627566-
  1861 00000262 6665722E0D0A       
  1862                                  .initial_error_2.length: equ $ - .initial_error_2
  1863 00000268 4572726F723A205465-     .subsequent_error_2:	db "Error: Test program decompressed wrongly during test.",13,10
  1863 00000271 73742070726F677261-
  1863 0000027A 6D206465636F6D7072-
  1863 00000283 65737365642077726F-
  1863 0000028C 6E676C792064757269-
  1863 00000295 6E6720746573742E0D-
  1863 0000029E 0A                 
  1864                                  .subsequent_error_2.length: equ $ - .subsequent_error_2
  1865                                  %endif
  1866 0000029F 4572726F723A20496E-     .cmdline_error:	db "Error: Invalid command line input.",13,10
  1866 000002A8 76616C696420636F6D-
  1866 000002B1 6D616E64206C696E65-
  1866 000002BA 20696E7075742E0D0A 
  1867                                  .cmdline_error.length: equ $ - .cmdline_error
  1868 000002C3 3132343235              .error_stdout:	_autodigits paras(_TEST_PROGRAM_DECOMPRESSED_SIZE 				+ (payload_end - payload) 				+ (init1_end - init1_start) 				+ ADDITIONAL_MEMORY 				)
  1873 000002C8 0D0A                    		db 13,10
  1874                                  .error_stdout.length: equ $ - .error_stdout
  1875                                  
  1876                                  
  1877                                  		; Move paragraphs
  1878                                  		;
  1879                                  		; INP:	ax => source
  1880                                  		;	dx => destination
  1881                                  		;	cx = number of paragraphs
  1882                                  		; CHG:	-
  1883                                  		; OUT:	ax and dx unchanged
  1884                                  		; Note:	Doesn't work correctly on HMA; doesn't always wrap to LMA either.
  1885                                  		;	Do not provide a wrapped/HMA source or destination!
  1886                                  init2_movp:
  1887 000002CA 51                      	push cx
  1888 000002CB 1E                      	push ds
  1889 000002CC 56                      	push si
  1890 000002CD 06                      	push es
  1891 000002CE 57                      	push di
  1892                                  
  1893 000002CF 39D0                    	cmp ax, dx		; source above destination ?
  1894 000002D1 770A                    	ja .up			; yes, move up (forwards) -->
  1895 000002D3 747B                    	je .return		; same, no need to move -->
  1896 000002D5 50                      	push ax
  1897 000002D6 01C8                    	add ax, cx		; (expected not to carry)
  1898 000002D8 39D0                    	cmp ax, dx		; end of source is above destination ?
  1899 000002DA 58                      	pop ax
  1900 000002DB 7730                    	ja .down		; yes, move from top down -->
  1901                                  	; Here, the end of source is below-or-equal the destination,
  1902                                  	;  so they do not overlap. In this case we prefer moving up.
  1903                                  
  1904                                  .up:
  1905 000002DD 50                      	push ax
  1906 000002DE 52                      	push dx
  1907                                  .uploop:
  1908 000002DF 8ED8                    	mov ds, ax
  1909 000002E1 8EC2                    	mov es, dx
  1910 000002E3 31FF                    	xor di, di
  1911 000002E5 31F6                    	xor si, si		; -> start of segment
  1912 000002E7 81E90010                	sub cx, 1000h		; 64 KiB left ?
  1913 000002EB 7610                    	jbe .uplast		; no -->
  1914 000002ED 51                      	push cx
  1915 000002EE B90080                  	mov cx, 10000h /2
  1916 000002F1 F3A5                    	rep movsw		; move 64 KiB
  1917 000002F3 59                      	pop cx
  1918 000002F4 050010                  	add ax, 1000h
  1919 000002F7 81C20010                	add dx, 1000h		; -> next segment
  1920 000002FB EBE2                    	jmp short .uploop	; proceed for more -->
  1921                                  .uplast:
  1922 000002FD 81C10010                	add cx, 1000h		; restore counter
  1923 00000301 D1E1                    	shl cx, 1
  1924 00000303 D1E1                    	shl cx, 1
  1925 00000305 D1E1                    	shl cx, 1		; *8, paragraphs to words
  1926 00000307 F3A5                    	rep movsw		; move last part
  1927 00000309 5A                      	pop dx
  1928 0000030A 58                      	pop ax
  1929 0000030B EB43                    	jmp short .return
  1930                                  
  1931                                  .down:
  1932 0000030D FD                      	std			; _AMD_ERRATUM_109_WORKAROUND as below
  1933                                  .dnloop:
  1934 0000030E 81E90010                	sub cx, 1000h		; 64 KiB left ?
  1935 00000312 761A                    	jbe .dnlast		; no -->
  1936 00000314 50                      	push ax
  1937 00000315 52                      	push dx
  1938 00000316 01C8                    	add ax, cx
  1939 00000318 01CA                    	add dx, cx
  1940 0000031A 8ED8                    	mov ds, ax		; -> 64 KiB not yet moved
  1941 0000031C 8EC2                    	mov es, dx
  1942 0000031E 5A                      	pop dx
  1943 0000031F 58                      	pop ax
  1944 00000320 BFFEFF                  	mov di, -2
  1945 00000323 89FE                    	mov si, di		; moved from last word down
  1946 00000325 51                      	push cx
  1947 00000326 B90080                  	mov cx, 10000h /2
  1948 00000329 F3A5                    	rep movsw		; move 64 KiB
  1949 0000032B 59                      	pop cx
  1950 0000032C EBE0                    	jmp short .dnloop	; proceed for more -->
  1951                                  .dnlast:
  1952 0000032E 81C10010                	add cx, 1000h		; restore counter
  1953 00000332 D1E1                    	shl cx, 1
  1954 00000334 D1E1                    	shl cx, 1
  1955 00000336 D1E1                    	shl cx, 1		; *8, paragraphs to words
  1956 00000338 89CF                    	mov di, cx
  1957 0000033A 4F                      	dec di
  1958 0000033B D1E7                    	shl di, 1		; words to offset, -> last word
  1959 0000033D 89FE                    	mov si, di
  1960 0000033F 8ED8                    	mov ds, ax
  1961 00000341 8EC2                    	mov es, dx		; first segment correct
  1962                                  
  1963                                  		; Refer to comment in init0_movp.
  1964                                  %if _AMD_ERRATUM_109_WORKAROUND
  1965 00000343 E308                    	jcxz @FF
  1966 00000345 83F914                  	cmp cx, 20
  1967 00000348 7703                    	ja @FF
  1968                                  @@:
  1969 0000034A A5                      	movsw
  1970 0000034B E2FD                    	loop @B
  1971                                  @@:
  1972                                  %endif
  1973 0000034D F3A5                    	rep movsw		; move first part
  1974 0000034F FC                      	cld
  1975                                  .return:
  1976 00000350 5F                      	pop di
  1977 00000351 07                      	pop es
  1978 00000352 5E                      	pop si
  1979 00000353 1F                      	pop ds
  1980 00000354 59                      	pop cx
  1981 00000355 C3                      	retn
  1982                                  
  1983                                  
  1984 00000356 90<rep Ah>              	align 16
  1985                                  
  1986                                  	strdef UNCOMPRESSED_FILE, "lDOSLOAD.BIN"
  1987                                  %if _INCLUDE_UNCOMPRESSED
  1988                                  payload_uncompressed:
  1989 00000360 <bin 1D9C0h>            	incbin _UNCOMPRESSED_FILE
  1990                                  .end:
  1991 0001DD20 26                      	db 38
  1992 0001DD21 26<rep Fh>              	align 16, db 38
  1993                                  %endif
  1994                                  init2_end:
  1995                                  %endif
  1996                                  
